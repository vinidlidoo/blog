<!doctype html><html lang=fr><head><meta charset=UTF-8><meta content="default-src 'self';font-src 'self' data:;frame-src platform.twitter.com giscus.app;img-src 'self' data: pub-94e31bf482a74272bb61e9559b598705.r2.dev;media-src 'self' pub-94e31bf482a74272bb61e9559b598705.r2.dev;form-action 'self' buttondown.com formspree.io;connect-src 'self';script-src 'self' platform.twitter.com giscus.app" http-equiv=Content-Security-Policy><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://vinidlidoo.github.io name=base><title>
vinidlidoo • Verkle Trees : Engagements Polynomiaux (Partie 2/2)</title><link href=https://vinidlidoo.github.io/img/favicon.png rel=icon type=image/png><link href="https://vinidlidoo.github.io/custom_subset.css?h=0b9535a28bc3d5bf2321" rel=stylesheet><link href="https://vinidlidoo.github.io/main.css?h=045c365e19a4d50a64bb" rel=stylesheet><link href="https://vinidlidoo.github.io/css/details.css?h=8559b4e109b168c7cfa0" rel=stylesheet><link href="https://vinidlidoo.github.io/css/giscus-fix.css?h=dc895b97fbaf0f0d9908" rel=stylesheet><link href="https://vinidlidoo.github.io/css/newsletter.css?h=c872153c9c367e0bee16" rel=stylesheet><link href="https://vinidlidoo.github.io/css/contact.css?h=572915e83e02eb90c290" rel=stylesheet><link href="https://vinidlidoo.github.io/skins/indigo_ingot.css?h=d429472afbb246441b1a" rel=stylesheet><meta content="light dark" name=color-scheme><meta content="Comment un seul point de courbe peut engager 256 enfants, et pourquoi les preuves passent de kilo-octets à octets" name=description><meta content="Comment un seul point de courbe peut engager 256 enfants, et pourquoi les preuves passent de kilo-octets à octets" property=og:description><meta content="Verkle Trees : Engagements Polynomiaux (Partie 2/2)" property=og:title><meta content=article property=og:type><meta content="https://vinidlidoo.github.io/img/verkle-tree-banner.webp?h=67a03587241b9507a7b1" property=og:image><meta content=1200 property=og:image:width><meta content=670 property=og:image:height><meta content="https://vinidlidoo.github.io/img/verkle-tree-banner.webp?h=67a03587241b9507a7b1" name=twitter:image><meta content=summary_large_image name=twitter:card><meta content=en_GB property=og:locale:alternate><link href=https://vinidlidoo.github.io/blog/verkle-trees-polynomial-commitments/ hreflang=en rel=alternate><meta content=en_GB property=og:locale:alternate><link href=https://vinidlidoo.github.io/fr/blog/verkle-trees-polynomial-commitments/ hreflang=fr rel=alternate><meta content=en_GB property=og:locale:alternate><link href=https://vinidlidoo.github.io/ja/blog/verkle-trees-polynomial-commitments/ hreflang=ja rel=alternate><meta content=https://vinidlidoo.github.io/fr/blog/verkle-trees-polynomial-commitments/ property=og:url><meta content=vinidlidoo property=og:site_name><noscript><link href=https://vinidlidoo.github.io/no_js.css rel=stylesheet></noscript><script src=https://vinidlidoo.github.io/js/initializeTheme.min.js></script><script defer src=https://vinidlidoo.github.io/js/themeSwitcher.min.js></script><script src="https://vinidlidoo.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><script defer src=https://vinidlidoo.github.io/js/lunr/lunrStemmerSupport.min.js></script><script defer src=https://vinidlidoo.github.io/js/lunr/lunr.fr.min.js></script><body><a href=#main-content id=skip-link>Skip to content</a><header><nav class=navbar><div class=nav-title><a class=home-title href=https://vinidlidoo.github.io/fr/>vinidlidoo</a></div><div class=nav-navs><ul><li><a class="nav-links no-hover-padding" href=https://vinidlidoo.github.io/fr/blog/>blog </a><li><a class="nav-links no-hover-padding" href=https://vinidlidoo.github.io/fr/tags/>étiquettes </a><li><a class="nav-links no-hover-padding" href=https://vinidlidoo.github.io/fr/contact/>contact </a><li class=menu-icons-container><ul class=menu-icons-group><li class="js menu-icon"><div aria-label="Press $SHORTCUT to open search" class="search-icon interactive-icon" title="Press $SHORTCUT to open search" id=search-button role=button tabindex=0><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="M784-120 532-372q-30 24-69 38t-83 14q-109 0-184.5-75.5T120-580q0-109 75.5-184.5T380-840q109 0 184.5 75.5T640-580q0 44-14 83t-38 69l252 252-56 56ZM380-400q75 0 127.5-52.5T560-580q0-75-52.5-127.5T380-760q-75 0-127.5 52.5T200-580q0 75 52.5 127.5T380-400Z"/></svg></div><li class=language-switcher><details class=dropdown><summary aria-label="Language selection" title="Language selection" aria-haspopup=true role=button><div class=language-switcher-icon></div></summary> <div class=dropdown-content role=menu>Français<a aria-label=日本語 href=https://vinidlidoo.github.io/ja/blog/verkle-trees-polynomial-commitments/ lang=ja role=menuitem>日本語</a><a aria-label=English href=https://vinidlidoo.github.io/blog/verkle-trees-polynomial-commitments/ lang=en role=menuitem>English</a></div></details><li class="theme-switcher-wrapper js"><div aria-label="Toggle dark mode" title="Toggle dark/light mode" aria-pressed=false class=theme-switcher role=button tabindex=0></div><div aria-label="Reset mode to default" class="theme-resetter arrow" title="Reset mode to default" aria-hidden=true role=button tabindex=0></div></ul></ul></div></nav></header><div class=content id=main-content><main><article class=h-entry><h1 class="p-name article-title">Verkle Trees : Engagements Polynomiaux (Partie 2/2)</h1><a class="u-url u-uid" href=https://vinidlidoo.github.io/fr/blog/verkle-trees-polynomial-commitments/></a><ul class=meta><span class="hidden p-author h-card"> <a class=u-url href=https://vinidlidoo.github.io rel=author title=Vincent>Vincent</a> </span><li><time class=dt-published datetime=2026-02-13>13th Feb 2026</time><li title="2588 words"><span aria-hidden=true class=separator>•</span>13 min read<li class=tag><span aria-hidden=true class=separator>•</span>Étiquettes: <li class=tag><a class=p-category href=https://vinidlidoo.github.io/fr/tags/crypto/>crypto</a>, <li class=tag><a class=p-category href=https://vinidlidoo.github.io/fr/tags/computer-science/>computer-science</a></ul><ul class="meta last-updated"><li><time class=dt-updated datetime=2026-02-16>Updated on 16th Feb 2026</time><li><span aria-hidden=true class=separator>•</span><a class=external href=https://github.com/vinidlidoo/vinidlidoo.github.io/commits/main/content/blog/verkle-trees-polynomial-commitments.fr.md>See changes</a></ul><p class=p-summary hidden>Comment un seul point de courbe peut engager 256 enfants, et pourquoi les preuves passent de kilo-octets à octets<section class="e-content body"><p><img alt="Verkle tree : des courbes polynomiales lisses convergent depuis de nombreux noeuds feuilles vers un seul point d'engagement lumineux" src=/img/verkle-tree-banner.webp><p>La <a href=https://vinidlidoo.github.io/fr/blog/ethereum-merkle-patricia-trie/>Partie 1</a> s'est terminée sur un problème : les preuves de Merkle dans le state trie d'Ethereum sont trop volumineuses pour la validation sans état. À plusieurs Mo par bloc, le coût en bande passante de l'inclusion des preuves pousserait les validateurs individuels vers les data centers.<p>Les Verkle trees proposent une réponse : remplacer les engagements par hachage par des <strong>engagements polynomiaux</strong>. Chaque noeud stocke un point de courbe au lieu d'un hash, et les noeuds passent de 16 enfants à 256. Au lieu de prouver une feuille en fournissant tous les hashs des noeuds frères sur le chemin jusqu'à la racine (~3 Ko), le prouveur envoie une petite preuve à chaque niveau (~150 octets), environ 20× plus compacte. À la fin de cet article, vous comprendrez comment.<h2 id=des-valeurs-a-un-polynome>Des valeurs à un polynôme</h2><p>L'idée centrale est de construire un <strong>engagement vectoriel</strong> : un schéma qui engage plusieurs valeurs et permet de prouver n'importe laquelle sans révéler les autres. C'est de là que vient le « V » de Verkle (<strong>V</strong>ector commitment + M<strong>erkle</strong>).<sup class=footnote-reference id=fr-1-1><a href=#fn-1>1</a></sup> Même structure d'arbre, mais un engagement différent à chaque noeud.<p>On y parvient avec des polynômes. On représente les 256 enfants d'un noeud comme les évaluations d'un seul polynôme :<p>$$P(x) = a_0 + a_1 x + a_2 x^2 + \cdots + a_{255} x^{255}$$<p>On choisit les positions $0, 1, \ldots, 255$ et on détermine les coefficients $a_0, \ldots, a_{255}$ de sorte que :<p>$$P(i) = v_i \quad \text{pour } i = 0, 1, \ldots, 255$$<p>On obtient un polynôme de degré 255 qui passe par chaque valeur enfant. Un tel polynôme existe toujours et est unique : $n$ paires position-valeur déterminent exactement un polynôme de degré $n - 1$.<sup class=footnote-reference id=fr-2-1><a href=#fn-2>2</a></sup> L'algorithme qui trouve ce polynôme s'appelle l'<strong>interpolation de Lagrange</strong>.<details><summary>Comment fonctionne l'interpolation de Lagrange</summary> <p>L'idée : construire des polynômes de base qui valent chacun 1 en un point et 0 en tous les autres, puis prendre leur somme pondérée. Pour $n$ points, le polynôme de la <strong>base de Lagrange</strong> pour la position $j$ est :</p> <p>$$L_j(x) = \prod_{\substack{m=0 \\ m \neq j}}^{n-1} \frac{x - m}{j - m}$$</p> <p>$L_j(j) = 1$ et $L_j(m) = 0$ pour tout $m \neq j$. Le polynôme complet est leur somme pondérée :</p> <p>$$P(x) = \sum_{i=0}^{n-1} v_i L_i(x)$$</p> <p>Par exemple, avec 4 points, le polynôme de base pour la position 0 est :</p> <p>$$L_0(x) = \frac{(x-1)(x-2)(x-3)}{(0-1)(0-2)(0-3)}$$</p> <p>Il vaut 1 quand $x = 0$ et 0 pour $x = 1, 2, 3$. Le polynôme complet $P(x) = v_0 L_0(x) + v_1 L_1(x) + v_2 L_2(x) + v_3 L_3(x)$ passe par les quatre valeurs.</p></details><p>Jusqu'ici, c'est de l'algèbre pure. On a un polynôme qui encode les enfants, mais partager $P$ directement signifierait transmettre les 256 coefficients, pas mieux qu'envoyer les enfants eux-mêmes. Il faut un moyen de comprimer $P$ en un engagement court. C'est là qu'interviennent les courbes elliptiques.<h2 id=un-point-de-courbe-pour-un-polynome-entier>Un point de courbe pour un polynôme entier</h2><p>Petit avertissement : toute l'arithmétique à partir d'ici (les coefficients du polynôme, ses évaluations, les scalaires de la courbe elliptique) se fait dans le même <a href=https://vinidlidoo.github.io/fr/blog/math-behind-private-key/#les-corps-des-nombres-avec-de-l-arithmetique><strong>corps fini</strong></a> $\mathbb{F}_p$.<p>Supposons qu'il existe un scalaire secret $s$ que personne ne connaît, mais que tout le monde ait accès aux <strong>paramètres publics</strong> suivants :<p>$$G, \ sG, \ s^2G, \ \ldots, \ s^dG$$<p>La façon dont $s$ est généré et détruit est traitée dans l'<a href=https://vinidlidoo.github.io/fr/blog/verkle-trees-polynomial-commitments/#trusted-setup>Annexe</a>. Pour l'instant, considérons ces points comme donnés. Pour engager $P(x)$, le prouveur calcule :<p>$$\begin{aligned} C &= a_0 \cdot G + a_1 \cdot sG + \cdots + a_d \cdot s^dG \\ &= P(s) \cdot G \end{aligned}$$<p>Le prouveur n'a pas besoin de connaître $s$ pour calculer $C$ : il combine simplement les coefficients de son polynôme avec les paramètres publics.<sup class=footnote-reference id=fr-3-1><a href=#fn-3>3</a></sup><p>Le résultat est un seul point de courbe (48 octets compressés) qui engage le polynôme entier. De la même manière qu'un hash résistant aux collisions ne produit pas la même sortie pour deux entrées différentes, cet engagement est <strong>liant</strong> : deux polynômes distincts $P \neq Q$ vérifient $P(s) \neq Q(s)$ avec une probabilité écrasante, donc leurs engagements $C = P(s) \cdot G$ sont distincts.<sup class=footnote-reference id=fr-4-1><a href=#fn-4>4</a></sup><p>Chaque noeud Verkle stocke désormais ce $C$ au lieu d'un hash. On a l'engagement ; il faut maintenant un moyen de prouver ce qu'il contient.<h2 id=preuves-d-ouverture-prouver-une-seule-valeur>Preuves d'ouverture : prouver une seule valeur</h2><p>Alice veut <strong>ouvrir</strong> l'engagement $C$ en position $z$ pour vérifier qu'il contient la valeur $y$. Le prouveur doit la convaincre que $P(z) = y$ sans révéler $P$ ni aucun autre enfant. Comment ?<p>Le point essentiel vient de l'algèbre des polynômes : si $P(z) = y$, alors $P(x) - y$ a une racine en $x = z$, donc $(x - z)$ le divise exactement. On définit le <strong>polynôme quotient</strong> :<p>$$Q(x) = \frac{P(x) - y}{x - z}$$<p>Cette division est exacte si et seulement si $P(z) = y$. Une affirmation fausse laisse un reste, et le prouveur ne peut pas produire un $Q$ valide.<p>La <strong>preuve d'ouverture</strong> $\pi$ est simplement un engagement sur $Q$ :<p>$$\pi = Q(s) \cdot G$$<p>Un seul point de courbe. Pas besoin de noeuds frères.<p>Le vérificateur doit maintenant s'assurer que $Q$ est légitime. Si la division est exacte, en remultipliant on obtient une identité polynomiale vraie en tout point, y compris $x = s$ :<p>$$P(s) - y = Q(s) \cdot (s - z) \tag{1}$$<p>Le vérificateur ne peut pas vérifier cette équation directement. Il dispose de $C = P(s) \cdot G$ et $\pi = Q(s) \cdot G$, mais les points de courbe <strong>masquent</strong> leurs scalaires : extraire $P(s)$ ou $Q(s)$ à partir de ces points est le <a href=https://vinidlidoo.github.io/fr/blog/math-behind-private-key/>problème du logarithme discret</a>. Et $(s - z)$ nécessite de connaître $s$, que personne ne possède.<h2 id=verification-de-la-preuve-par-couplage>Vérification de la preuve par couplage</h2><p>Un <strong>couplage</strong> $e$ est une fonction qui prend un point d'un groupe de courbe ($\mathbb{G}_1$) et un point d'un autre ($\mathbb{G}_2$) et produit un élément dans un groupe cible, avec la propriété de <strong>bilinéarité</strong> :<p>$$e(aG_1, bG_2) = e(G_1, G_2)^{ab}$$<p>On donne en entrée un point masquant un scalaire $a$ et un autre masquant $b$, et la sortie capture leur produit. On ne peut pas extraire $a$ ou $b$, mais on peut vérifier si <strong>deux produits sont égaux</strong> en comparant les sorties des couplages.<sup class=footnote-reference id=fr-5-1><a href=#fn-5>5</a></sup> Les couplages nécessitent deux groupes de courbe distincts ; le $G$ que l'on a utilisé vit dans $\mathbb{G}_1$ (devenant $G_1$), et $G_2$ est un générateur de $\mathbb{G}_2$. Les paramètres publics incluent également $sG_2$.<p>La stratégie : exprimer chaque côté de l'équation $(1)$ comme un produit de deux scalaires, puis placer un facteur dans $\mathbb{G}_1$ et l'autre dans $\mathbb{G}_2$. Le côté droit se factorise naturellement en $Q(s) \cdot (s - z)$. Le côté gauche est simplement $(P(s) - y) \cdot 1$, donc on le couple avec le générateur $G_2$ :<p><strong>Côté gauche</strong> : $(P(s) - y)G_1 = C - yG_1$, donc<p>$$e(C - yG_1, G_2) = e(G_1, G_2)^{P(s) - y}$$<p><strong>Côté droit</strong> : $Q(s) \cdot G_1 = \pi$ et $(s - z)G_2 = sG_2 - zG_2$, donc<p>$$e(\pi, sG_2 - zG_2) = e(G_1, G_2)^{Q(s)(s-z)} $$<p>Ces deux membres sont égaux si et seulement si l'équation $(1)$ est vérifiée, donc la vérification se réduit à un seul test :<p>$$e(C - yG_1, G_2) = e(\pi, sG_2 - zG_2) \tag{2}$$<p>Le vérificateur connaît chaque variable de cette équation : $C$ et $\pi$ proviennent du prouveur, $y$ et $z$ sont la valeur annoncée et la position, et $G_1$, $G_2$, $sG_2$ sont des paramètres publics. Un seul couplage, pas de noeuds frères.<h2 id=vue-d-ensemble>Vue d'ensemble</h2><p>Prenons du recul et considérons ce que l'on vient de construire. Un noeud avec 256 enfants est encodé en un polynôme et condensé en un seul point de courbe. Pour ouvrir un enfant, le prouveur divise par la racine correspondante pour obtenir un polynôme quotient, et le condense en un second point de courbe. Un couplage traverse alors les deux groupes de courbes et, par bilinéarité, vérifie que la division est exacte à partir des seuls points de courbe. Deux points, une vérification, terminé. On a presque l'impression d'avoir percé un secret de l'univers.<p>Ce schéma engagement-ouverture-vérification s'appelle <strong><a href=https://en.wikipedia.org/wiki/Commitment_scheme#KZG_commitment>KZG</a></strong> (Kate-Zaverucha-Goldberg) : un engagement par noeud, une preuve d'ouverture par niveau. Un arbre de Merkle de largeur 16 nécessite ~8-10 niveaux et 15 hashs de noeuds frères (480 octets) à chacun. Un arbre Verkle de largeur 256 couvre le même état en seulement ~3 niveaux,<sup class=footnote-reference id=fr-6-1><a href=#fn-6>6</a></sup> avec une seule preuve d'environ 48 octets à chacun :</p><img alt="Comparaison côte à côte de la structure de preuve Merkle vs Verkle : Merkle nécessite 15 hashs de noeuds frères par niveau tandis que Verkle ne nécessite qu'une preuve par niveau, résultant en des preuves ~20× plus petites" src=/img/merkle-vs-verkle-comparison.webp><details><summary>Exemple pas à pas</summary> <p>Alice veut vérifier son solde en ETH. Son adresse hashée donne les positions $k_0, k_1, k_2$ qui tracent un chemin : racine $\to$ $C_1$ $\to$ $C_2$ $\to$ feuille $v$. Le prouveur envoie à Alice la valeur de la feuille $v$, les engagements intermédiaires $C_1$ et $C_2$, et une preuve d'ouverture $\pi_i$ à chaque niveau. Alice vérifie de bas en haut :</p> <ol><li>$C_2$ ouvre-t-il en position $k_2$ sur la valeur $v$ ? Vérifier $\pi_2$.<li>$C_1$ ouvre-t-il en position $k_1$ sur $C_2$ ?<sup class=footnote-reference id=fr-7-1><a href=#fn-7>7</a></sup> Vérifier $\pi_1$.<li>$C_0$ ouvre-t-il en position $k_0$ sur $C_1$ ? Vérifier $\pi_0$.<li>$C_0$ correspond-il au state root dans le block header ? Terminé.</ol> <p>Trois preuves d'ouverture (~48 octets chacune), environ 150 octets au total.</p></details><p>Les engagements polynomiaux <strong>suppriment aussi un compromis auquel les preuves de Merkle par hachage sont confrontées.</strong> Dans un arbre de Merkle, réduire la largeur donne des preuves plus petites (moins de frères par niveau), mais un arbre plus profond implique davantage de lectures disque par recherche (le goulot d'étranglement de l'<a href=https://vinidlidoo.github.io/fr/blog/ethereum-merkle-patricia-trie/#annexe>annexe de la Partie 1</a>). La validation sans état atténue le problème de profondeur, mais la taille des preuves croît toujours avec la largeur. Avec les engagements polynomiaux, ce n'est plus le cas : les noeuds peuvent être larges et l'arbre peu profond.<h2 id=la-proposition-verkle-d-ethereum-ipa>La proposition Verkle d'Ethereum : IPA</h2><p>Les chiffres ci-dessus reflètent les tailles de preuves KZG. La <a href=https://notes.ethereum.org/@vbuterin/verkle_tree_eip>proposition de Verkle tree d'Ethereum</a> a opté pour d'autres briques : un engagement <strong>Pedersen</strong>, une technique de preuve <strong>IPA</strong>, et une courbe <strong>Bandersnatch</strong>. L'architecture est la même ; les preuves individuelles sont plus volumineuses (~544 octets) et la vérification plus lente, mais le compromis en valait la peine : pas de cérémonie de confiance. Si le secret $s$ d'une cérémonie KZG était un jour reconstitué, l'ensemble du schéma s'effondrerait. Pour un state tree sécurisant toute la valeur d'Ethereum, la communauté a préféré éliminer entièrement ce risque.<p>Au niveau des blocs, le <a href=https://dankradfeist.de/ethereum/2021/06/18/pcs-multiproofs.html>schéma multiproof</a> de Dankrad Feist fusionne toutes les preuves d'ouverture d'un bloc en une seule preuve de taille constante (~200 octets), quel que soit le nombre d'accès à l'état dans le bloc.<h2 id=et-ensuite>Et ensuite</h2><p>Les Verkle trees semblent désormais peu susceptibles d'être intégrés à Ethereum : leur dépendance à la cryptographie sur courbes elliptiques ne résiste pas aux attaques quantiques, et la communauté s'oriente plutôt vers un <a href=https://eips.ethereum.org/EIPS/eip-7864>arbre d'état binaire basé sur les fonctions de hachage</a>. Les idées qu'on a construites ici (engager des données avec des polynômes, prouver des propriétés sans tout révéler), cependant, sont fondamentales pour quelque chose de plus grand : les <strong>preuves à connaissance nulle</strong>. Elles permettent de prouver non seulement l'accès à l'état, mais que l'exécution d'un bloc entier est correcte, le tout en une seule preuve compacte. Des preuves plus petites ne résolvent pas tout (par exemple, quelqu'un doit toujours stocker l'état, qui ne cesse de croître, pour construire les blocs), mais de plus en plus, l'objectif est de prouver davantage et stocker moins.<p>La cryptographie derrière les preuves à connaissance nulle, des circuits arithmétiques aux différences entre systèmes de preuve, est un sujet que j'explorerai bientôt sur ce blog. À suivre.<hr><h2 id=annexe>Annexe</h2><p><a id=trusted-setup></a><details><summary>La cérémonie de confiance (Trusted Setup)</summary> <p>Les engagements KZG nécessitent des paramètres publics : les points de courbe $G, sG, s^2G, \ldots, s^dG$. Le secret $s$ doit être détruit après sa génération. Comment détruire un nombre que personne ne devrait jamais connaître ?</p> <p>La cérémonie utilise un <strong>calcul multipartite</strong>. Les participants contribuent de l'aléa séquentiellement :</p> <ol><li>Le participant 1 choisit un $s_1$ aléatoire, calcule $s_1^i G$ pour chaque puissance $i$, publie le résultat, et détruit $s_1$.<li>Le participant 2 choisit $s_2$, « re-randomise » la sortie précédente pour produire $(s_1 s_2)^i G$, et détruit $s_2$.<li>Cela continue pour tous les participants.</ol> <p>La sortie finale est $(s_1 s_2 \cdots s_n)^i G$. Le secret combiné $s = s_1 s_2 \cdots s_n$ est sûr tant qu'<strong>au moins un participant</strong> a honnêtement détruit sa contribution. Même si tous les autres participants sont malveillants, un seul participant honnête suffit.</p> <p>Ethereum a organisé exactement ce type de cérémonie pour <a href=https://eips.ethereum.org/EIPS/eip-4844>EIP-4844</a> (proto-danksharding) début 2023. Plus de 140 000 participants ont contribué, ce qui en fait la plus grande cérémonie de confiance jamais réalisée. Les paramètres obtenus sont utilisés aujourd'hui pour les engagements de blobs sur Ethereum.</p></details><hr><section class=footnotes><ol class=footnotes-list><li id=fn-1><p>Le nom et la construction ont été introduits par John Kuszmaul dans <a href=https://math.mit.edu/research/highschool/primes/materials/2018/Kuszmaul.pdf>Verkle Trees</a> (2018). <a href=#fr-1-1>↩</a></p><li id=fn-2><p>Existence : l'interpolation de Lagrange construit $P$ directement. Unicité : supposons que $P$ et $Q$ passent tous deux par les mêmes $n$ points. Alors $D = P - Q$ s'annule aux $n$ points, mais $D$ est de degré au plus $n-1$, donc a au plus $n-1$ racines. Contradiction, sauf si $D = 0$, c'est-à-dire $P = Q$. Voir <a href=https://en.wikipedia.org/wiki/Polynomial_interpolation>interpolation polynomiale</a> (théorème d'unisolvence). <a href=#fr-2-1>↩</a></p><li id=fn-3><p>Cela fonctionne parce que la multiplication scalaire se distribue sur l'addition des points : $a_0 \cdot G + a_1 \cdot sG = (a_0 + a_1 s)G$. L'application $f(a) = aG$ est un homomorphisme de groupes des scalaires vers les points de courbe. <a href=#fr-3-1>↩</a></p><li id=fn-4><p>Si $P \neq Q$, alors $D = P - Q$ est un polynôme non nul de degré au plus $d$, il a donc au plus $d$ racines dans $\mathbb{F}_p$. Pour que les engagements coïncident, $s$ devrait être l'une de ces $\leq d$ valeurs parmi $p$ au total. Cette probabilité est au plus $d/p$, ce qui est négligeable puisque $p \sim 2^{255}$ et $d = 255$. <a href=#fr-4-1>↩</a></p><li id=fn-5><p>Les courbes compatibles avec les couplages possèdent une structure spéciale qui le permet. Toutes les courbes elliptiques ne supportent pas les couplages. BLS12-381, utilisée aujourd'hui dans Ethereum, a été conçue spécifiquement pour des couplages efficaces. <a href=#fr-5-1>↩</a></p><li id=fn-6><p>Avec 256 enfants par noeud, $256^3 \approx 16,7$ millions et $256^4 \approx 4,3$ milliards. Ethereum compte environ 250 millions de comptes plus les slots de stockage des contrats, donc une profondeur de 3-4 couvre l'état actuel. <a href=#fr-6-1>↩</a></p><li id=fn-7><p>Les évaluations polynomiales doivent être des scalaires, mais $C_2$ et $C_1$ sont des points de courbe. Les noeuds de branchement gèrent cela en convertissant chaque engagement enfant en un élément du corps (par exemple, sa coordonnée x sérialisée) avant d'interpoler le polynôme. La même chose s'applique à l'étape 3. <a href=#fr-7-1>↩</a></p></ol></section></section><p class=credit><em>Cet article a été écrit en collaboration avec <a href=https://claude.ai>Claude</a>.</em><form action=https://buttondown.com/api/emails/embed-subscribe/vinidlidoo class=embeddable-buttondown-form method=post target=_blank><label for=bd-email>Recevez mes nouveaux articles par email.</label><input id=bd-email name=email placeholder=your@email.com type=email><input value="S'abonner" type=submit></form></article></main><link href=https://vinidlidoo.github.io/katex.min.css rel=stylesheet><script defer src=https://vinidlidoo.github.io/js/katex.min.js></script><span class=hidden id=copy-success> Copied! </span><span class=hidden id=copy-init> Copy code to clipboard </span><script defer src=https://vinidlidoo.github.io/js/copyCodeToClipboard.min.js></script></div><footer><section><nav class="socials nav-navs"><ul><li><a class="nav-links no-hover-padding social" rel=" me" href=https://github.com/vinidlidoo> <img alt=github loading=lazy src=https://vinidlidoo.github.io/social_icons/github.svg title=github> </a><li><a class="nav-links no-hover-padding social" rel=" me" href=https://x.com/vinidlidoo> <img alt=x loading=lazy src=https://vinidlidoo.github.io/social_icons/x.svg title=x> </a></ul></nav><nav class=nav-navs></nav><div class=credits><small> <p><p>© 2026 Vincent Ethier</p> Powered by <a href=https://www.getzola.org>Zola</a> & <a href=https://github.com/welpo/tabi>tabi</a> </small></div></section><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><h1 class=visually-hidden id=modalTitle>Search</h1><div id=modal-content><div id=searchBar><div aria-hidden=true class=search-icon><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="M784-120 532-372q-30 24-69 38t-83 14q-109 0-184.5-75.5T120-580q0-109 75.5-184.5T380-840q109 0 184.5 75.5T640-580q0 44-14 83t-38 69l252 252-56 56ZM380-400q75 0 127.5-52.5T560-580q0-75-52.5-127.5T380-760q-75 0-127.5 52.5T200-580q0 75 52.5 127.5T380-400Z"/></svg></div><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search… role=combobox spellcheck=false><div class="close-icon interactive-icon" title="Clear search" id=clear-search role=button tabindex=0><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></div></div><div id=results-container><div id=results-info><span id=zero_results> No results</span><span id=one_results> 1 result</span><span id=many_results> $NUMBER results</span><span id=two_results> $NUMBER results</span><span id=few_results> $NUMBER results</span></div><div id=results role=listbox></div></div></div></div></footer>