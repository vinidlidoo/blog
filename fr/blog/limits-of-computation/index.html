<!doctype html><html lang=fr><head><meta charset=UTF-8><meta content="default-src 'self';font-src 'self' data:;frame-src platform.twitter.com giscus.app;img-src 'self' data: pub-94e31bf482a74272bb61e9559b598705.r2.dev;media-src 'self' pub-94e31bf482a74272bb61e9559b598705.r2.dev;form-action 'self' buttondown.com formspree.io;connect-src 'self';script-src 'self' platform.twitter.com giscus.app" http-equiv=Content-Security-Policy><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://vinidlidoo.github.io name=base><title>
vinidlidoo • Les limites du calcul (Partie 3/3)</title><link href=https://vinidlidoo.github.io/img/favicon.png rel=icon type=image/png><link href="https://vinidlidoo.github.io/custom_subset.css?h=0b9535a28bc3d5bf2321" rel=stylesheet><link href="https://vinidlidoo.github.io/main.css?h=045c365e19a4d50a64bb" rel=stylesheet><link href="https://vinidlidoo.github.io/css/details.css?h=8559b4e109b168c7cfa0" rel=stylesheet><link href="https://vinidlidoo.github.io/css/giscus-fix.css?h=dc895b97fbaf0f0d9908" rel=stylesheet><link href="https://vinidlidoo.github.io/css/newsletter.css?h=c872153c9c367e0bee16" rel=stylesheet><link href="https://vinidlidoo.github.io/css/contact.css?h=572915e83e02eb90c290" rel=stylesheet><link href="https://vinidlidoo.github.io/skins/indigo_ingot.css?h=d429472afbb246441b1a" rel=stylesheet><meta content="light dark" name=color-scheme><meta content="Ce que les machines de Turing ne peuvent pas faire, et pourquoi c'est important" name=description><meta content="Ce que les machines de Turing ne peuvent pas faire, et pourquoi c'est important" property=og:description><meta content="Les limites du calcul (Partie 3/3)" property=og:title><meta content=article property=og:type><meta content=en_GB property=og:locale:alternate><link href=https://vinidlidoo.github.io/blog/limits-of-computation/ hreflang=en rel=alternate><meta content=en_GB property=og:locale:alternate><link href=https://vinidlidoo.github.io/fr/blog/limits-of-computation/ hreflang=fr rel=alternate><meta content=en_GB property=og:locale:alternate><link href=https://vinidlidoo.github.io/ja/blog/limits-of-computation/ hreflang=ja rel=alternate><meta content=https://vinidlidoo.github.io/fr/blog/limits-of-computation/ property=og:url><meta content=vinidlidoo property=og:site_name><noscript><link href=https://vinidlidoo.github.io/no_js.css rel=stylesheet></noscript><script src=https://vinidlidoo.github.io/js/initializeTheme.min.js></script><script defer src=https://vinidlidoo.github.io/js/themeSwitcher.min.js></script><script src="https://vinidlidoo.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><script defer src=https://vinidlidoo.github.io/js/lunr/lunrStemmerSupport.min.js></script><script defer src=https://vinidlidoo.github.io/js/lunr/lunr.fr.min.js></script><body><a href=#main-content id=skip-link>Skip to content</a><header><nav class=navbar><div class=nav-title><a class=home-title href=https://vinidlidoo.github.io/fr/>vinidlidoo</a></div><div class=nav-navs><ul><li><a class="nav-links no-hover-padding" href=https://vinidlidoo.github.io/fr/blog/>blog </a><li><a class="nav-links no-hover-padding" href=https://vinidlidoo.github.io/fr/tags/>étiquettes </a><li><a class="nav-links no-hover-padding" href=https://vinidlidoo.github.io/fr/contact/>contact </a><li class=menu-icons-container><ul class=menu-icons-group><li class="js menu-icon"><div aria-label="Press $SHORTCUT to open search" class="search-icon interactive-icon" title="Press $SHORTCUT to open search" id=search-button role=button tabindex=0><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="M784-120 532-372q-30 24-69 38t-83 14q-109 0-184.5-75.5T120-580q0-109 75.5-184.5T380-840q109 0 184.5 75.5T640-580q0 44-14 83t-38 69l252 252-56 56ZM380-400q75 0 127.5-52.5T560-580q0-75-52.5-127.5T380-760q-75 0-127.5 52.5T200-580q0 75 52.5 127.5T380-400Z"/></svg></div><li class=language-switcher><details class=dropdown><summary aria-label="Language selection" title="Language selection" aria-haspopup=true role=button><div class=language-switcher-icon></div></summary> <div class=dropdown-content role=menu>Français<a aria-label=English href=https://vinidlidoo.github.io/blog/limits-of-computation/ lang=en role=menuitem>English</a><a aria-label=日本語 href=https://vinidlidoo.github.io/ja/blog/limits-of-computation/ lang=ja role=menuitem>日本語</a></div></details><li class="theme-switcher-wrapper js"><div aria-label="Toggle dark mode" title="Toggle dark/light mode" aria-pressed=false class=theme-switcher role=button tabindex=0></div><div aria-label="Reset mode to default" class="theme-resetter arrow" title="Reset mode to default" aria-hidden=true role=button tabindex=0></div></ul></ul></div></nav></header><div class=content id=main-content><main><article class=h-entry><h1 class="p-name article-title">Les limites du calcul (Partie 3/3)</h1><a class="u-url u-uid" href=https://vinidlidoo.github.io/fr/blog/limits-of-computation/></a><ul class=meta><span class="hidden p-author h-card"> <a class=u-url href=https://vinidlidoo.github.io rel=author title=Vincent>Vincent</a> </span><li><time class=dt-published datetime=2026-01-11>11th Jan 2026</time><li title="1573 words"><span aria-hidden=true class=separator>•</span>8 min read<li class=tag><span aria-hidden=true class=separator>•</span>Étiquettes: <li class=tag><a class=p-category href=https://vinidlidoo.github.io/fr/tags/math/>math</a>, <li class=tag><a class=p-category href=https://vinidlidoo.github.io/fr/tags/computer-science/>computer-science</a></ul><p class=p-summary hidden>Ce que les machines de Turing ne peuvent pas faire, et pourquoi c'est important<section class="e-content body"><p>Dans la <a href=https://vinidlidoo.github.io/fr/blog/turing-completeness/>Partie 2</a>, nous avons établi que la Turing-complétude est le plafond de la puissance de calcul. Tout formalisme raisonnable pour le « calcul » s'avère équivalent. On ne peut pas construire quelque chose de plus puissant qu'une machine de Turing.<p>Mais les machines de Turing peuvent-elles résoudre <em>tout</em> ?<p>Non. Et la preuve est d'une élégance surprenante. Elle nous conduira aussi, presque immédiatement, à l'un des résultats les plus célèbres des mathématiques : le théorème d'incomplétude de Gödel.<h2 id=le-probleme-de-l-arret>Le problème de l'arrêt</h2><p>Voici une question simple : étant donné un programme, finira-t-il un jour son exécution ? Dans notre formalisme de la <a href=https://vinidlidoo.github.io/fr/blog/turing-machines/>Partie 1</a>, un « programme » est un encodage $\langle M, w \rangle$ : une machine de Turing $M$ accompagnée de son entrée $w$, écrite comme donnée sur un ruban. La question de l'arrêt est donc : $M$ s'arrête-t-elle sur $w$ ?<p>Imaginons un <em>Décideur d'arrêt</em>, $H$. On lui soumet notre code et il nous dit « ceci termine (s'arrête) » ou « ceci boucle indéfiniment ». S'il existait, on pourrait l'utiliser sur n'importe quel programme pour détecter les boucles infinies avant déploiement, vérifier qu'un logiciel critique retourne toujours une réponse, garantir qu'une fonction récursive ne récursera pas éternellement. Incroyablement utile.<p>Le <strong>problème de l'arrêt</strong> demande : peut-on construire un tel $H$ ? Non pas pour un programme spécifique, mais une procédure générale qui répond correctement pour <em>tous</em> les $\langle M, w \rangle$.<p>Turing a prouvé qu'une telle procédure ne peut pas exister.<h2 id=intuition>Intuition</h2><p>Il est utile de remarquer que les réponses « oui » et « non » à la question de l'arrêt sont fondamentalement différentes.<p>Pour les réponses « oui », il suffit d'exécuter le programme assez longtemps. S'il s'arrête après une semaine, on peut dire avec confiance « oui, il s'arrête ».<p>Les réponses « non » sont différentes. Supposons qu'on exécute un programme depuis mille ans et qu'il ne se soit toujours pas arrêté. Peut-on dire « non, il ne s'arrêtera jamais » ? On ne peut pas. Peut-être qu'il s'arrêtera dans mille et un ans. À aucun moment l'exécution du programme ne nous autorise à dire « non ».<p>Cette asymétrie laisse entrevoir l'impossibilité. Prouvons-la maintenant.<h2 id=l-argument-diagonal>L'argument diagonal</h2><p>Supposons, par l'absurde, que nous ayons une procédure $H$ qui résout le problème de l'arrêt. Étant donné n'importe quel programme $P$ et une entrée, $H$ nous dit correctement si $P$ s'arrête.<p>Je vais maintenant utiliser $H$ comme sous-routine pour construire un nouveau programme. Appelons-le $Q$. Le programme $Q$ prend un autre programme $P$ en entrée et fait ce qui suit :<ol><li>Demander à $H$ : « Est-ce que $P$ s'arrêterait si on l'exécutait sur $P$ lui-même ? »<li>Si $H$ dit « oui, $P$ s'arrête sur $P$ » → $Q$ boucle indéfiniment<li>Si $H$ dit « non, $P$ ne s'arrête pas sur $P$ » → $Q$ s'arrête immédiatement</ol><p>C'est tout. $Q$ demande si $P$ s'arrête sur lui-même, puis fait le <em>contraire</em>.<p>L'étape 1 est la partie diagonale : on donne à $P$ sa propre description en entrée. C'est la même astuce autoréférentielle derrière <a href=https://vinidlidoo.github.io/fr/blog/russells-paradox/>le paradoxe de Russell</a> et l'argument diagonal de Cantor que nous avons explorés dans <a href=https://vinidlidoo.github.io/fr/blog/three-proofs-by-diagonalization/>Trois preuves par diagonalisation</a>.<p>Vient maintenant le coup de grâce. $Q$ est un programme. Que se passe-t-il si on exécute $Q$ sur <em>lui-même</em> ?<ul><li>Si $Q$ s'arrête sur $Q$, alors $H$ doit avoir dit « $Q$ s'arrête sur $Q$ », donc par l'étape 2, $Q$ boucle indéfiniment. Contradiction.<li>Si $Q$ ne s'arrête pas sur $Q$, alors $H$ doit avoir dit « $Q$ ne s'arrête pas sur $Q$ », donc par l'étape 3, $Q$ s'arrête. Contradiction.</ul><p>$Q$ s'arrête sur $Q$ si et seulement si $Q$ ne s'arrête pas sur $Q$. C'est impossible. Donc $H$ ne peut pas exister.<p>Le problème de l'arrêt est <strong>indécidable</strong>. $\blacksquare$<h2 id=pourquoi-c-est-important>Pourquoi c'est important</h2><p>Que signifie « indécidable » ? <strong>Un problème est décidable s'il existe une procédure qui s'arrête toujours et donne toujours la bonne réponse oui/non.</strong> Le problème de l'arrêt est indécidable : aucune telle procédure n'existe. Pour tout prétendu décideur d'arrêt, il existe un programme sur lequel il se trompe (ou boucle indéfiniment).<p>Le problème de l'arrêt peut sembler être un cas limite artificiel. Mais ce n'est que la partie visible de l'iceberg. Le <a href=https://en.wikipedia.org/wiki/Rice%27s_theorem>théorème de Rice</a>, prouvé en 1953 par Henry Gordon Rice, l'a généralisé : <em>toute</em> propriété non triviale de ce que calcule un programme est indécidable. Vous voulez savoir si un programme produit un jour une valeur spécifique ? Indécidable. S'il accède un jour au réseau ? Indécidable. S'il contient une vulnérabilité de sécurité ? Indécidable.<p>Cela explique pourquoi les outils d'analyse statique produisent parfois des faux positifs, pourquoi les compilateurs ne peuvent pas toujours éliminer le code mort, et pourquoi les logiciels antivirus ne peuvent pas détecter tous les malwares. L'analyse parfaite des programmes est mathématiquement impossible.<h2 id=le-theoreme-d-incompletude-de-godel>Le théorème d'incomplétude de Gödel</h2><p>Le problème de l'arrêt prouve immédiatement l'un des résultats les plus célèbres des mathématiques.<p>Au début du XXe siècle, David Hilbert a proposé un objectif ambitieux : trouver un ensemble fini d'axiomes à partir duquel toute affirmation vraie sur les nombres pourrait être dérivée mécaniquement. Partir d'axiomes de base comme « $0$ est un nombre » et « $x + 0 = x$ », ajouter des règles d'inférence, et en principe on pourrait prouver n'importe quelle affirmation arithmétique vraie.<p>Ici, il faut distinguer deux concepts :<ul><li>Une affirmation est <strong>vraie</strong> si elle décrit fidèlement les nombres tels qu'ils sont (par exemple, « il n'existe pas de plus grand nombre premier »)<li>Une affirmation est <strong>démontrable</strong> si elle peut être dérivée des axiomes via les règles d'inférence</ul><p>Ce n'est pas évidemment la même chose. La vérité concerne ce qui est effectivement le cas ; la démontrabilité concerne ce qui découle de vos hypothèses de départ. Le rêve de Hilbert, appelé le <strong>programme de Hilbert</strong>, était de les faire coïncider pour l'arithmétique : toute affirmation vraie devrait être démontrable, et toute affirmation démontrable devrait être vraie.<sup class=footnote-reference id=fr-1-1><a href=#fn-1>1</a></sup><p>Si un tel système existait, on pourrait construire une machine à prouver des théorèmes : partir des axiomes, appliquer les règles d'inférence de toutes les manières possibles, et produire chaque théorème au fur et à mesure qu'on le dérive.<sup class=footnote-reference id=fr-2-1><a href=#fn-2>2</a></sup> $1 + 1 = 2$. Tout nombre premier en a un plus grand. Une par une, toutes les affirmations vraies sur les nombres.<p>Voici l'observation clé : <strong>une telle machine résoudrait le problème de l'arrêt.</strong> Savoir si un programme s'arrête est une question sur des séquences finies de transitions d'états — exactement le genre de chose que l'arithmétique peut exprimer. Si le système d'axiomes était complet, alors pour tout programme $M$ et entrée $w$, soit « $M$ s'arrête sur $w$ » soit « $M$ ne s'arrête pas sur $w$ » serait démontrable. La machine d'énumération finirait par trouver la preuve qui existe, et nous aurions notre réponse.<p>Mais nous avons déjà prouvé que le problème de l'arrêt est indécidable. Donc le système ne peut pas être complet.<blockquote><p><strong>Premier théorème d'incomplétude de Gödel</strong> : Tout système axiomatique calculable<sup class=footnote-reference id=fr-3-1><a href=#fn-3>3</a></sup> capable d'exprimer l'arithmétique de base est incomplet. Il existe des affirmations vraies que le système ne peut pas prouver.</blockquote><p>C'est la conclusion : <strong>la vérité dépasse la démontrabilité.</strong> Quels que soient les axiomes choisis, certaines affirmations seront <em>indépendantes</em> — ni prouvables ni réfutables au sein du système.<h2 id=a-retenir>À retenir</h2><p>Nous avons tracé une frontière entre ce qui est calculable et ce qui ne l'est pas. Dans la Partie 2, nous avons vu que la Turing-complétude est le plafond : on ne peut pas calculer plus qu'une machine de Turing. Mais maintenant nous avons vu que ce plafond a des trous. Certains problèmes n'ont pas de procédure qui s'arrête toujours avec la bonne réponse.<p><strong>À l'intérieur</strong> : tout problème oui/non pour lequel on peut écrire une procédure qui termine. Ce nombre est-il premier ? La division par essais vous le dira. Combien font 347 × 892 ? La multiplication posée donne la réponse. Trier cette liste ? Le tri fusion termine avec le bon ordre. Ce sont des problèmes décidables : nous avons des procédures qui s'arrêtent toujours avec les bonnes réponses.<p><strong>À l'extérieur</strong> : le problème de l'arrêt n'est que le début. Le théorème de Rice nous dit que <em>toute</em> question intéressante sur le comportement d'un programme est indécidable. Ce code contient-il un bug ? Accédera-t-il un jour au réseau ? Est-il équivalent à cet autre programme ? Aucun algorithme général ne peut répondre à ces questions pour <strong>tous les programmes</strong>. Et Gödel nous dit que le problème est plus profond : certaines affirmations vraies sur les nombres ne peuvent jamais être prouvées à partir d'un ensemble fini d'axiomes.<p>Cette frontière ne dépend pas de la technologie. Ordinateurs plus rapides, ordinateurs quantiques, quoi qu'il arrive ensuite : le problème de l'arrêt restera indécidable, et l'arithmétique restera incomplète. Il existe des vérités qu'aucune procédure mécanique ne peut découvrir. C'est un fait profond sur la nature même du calcul.<hr><section class=footnotes><ol class=footnotes-list><li id=fn-1><p>La seconde moitié — toute affirmation démontrable est vraie — s'appelle la <em>correction</em>, et nous la voulons absolument. Un système incorrect prouve des choses fausses, ce qui est inutile. La première moitié — toute affirmation vraie est démontrable — s'appelle la <em>complétude</em>. Gödel a montré que la complétude est impossible. <a href=#fr-1-1>↩</a></p><li id=fn-2><p>Pourquoi peut-on énumérer les théorèmes ? Une preuve est une séquence finie d'étapes, chacune découlant mécaniquement des axiomes ou des étapes précédentes. On énumère toutes les séquences finies, on vérifie la validité de chacune, on produit la conclusion des preuves valides. Toute affirmation démontrable finit par apparaître. <a href=#fr-2-1>↩</a></p><li id=fn-3><p>Le système doit aussi être <em>consistant</em> : il ne prouve jamais à la fois $P$ et $\neg P$. Un système inconsistant peut prouver n'importe quoi (y compris des contradictions), rendant la « complétude » trivialement atteignable mais dénuée de sens. <a href=#fr-3-1>↩</a></p></ol></section></section><p class=credit><em>Cet article a été écrit en collaboration avec <a href=https://claude.ai>Claude</a>.</em><form action=https://buttondown.com/api/emails/embed-subscribe/vinidlidoo class=embeddable-buttondown-form method=post target=_blank><label for=bd-email>Recevez mes nouveaux articles par email.</label><input id=bd-email name=email placeholder=your@email.com type=email><input value="S'abonner" type=submit></form></article></main><link href=https://vinidlidoo.github.io/katex.min.css rel=stylesheet><script defer src=https://vinidlidoo.github.io/js/katex.min.js></script><span class=hidden id=copy-success> Copied! </span><span class=hidden id=copy-init> Copy code to clipboard </span><script defer src=https://vinidlidoo.github.io/js/copyCodeToClipboard.min.js></script></div><footer><section><nav class="socials nav-navs"><ul><li><a class="nav-links no-hover-padding social" rel=" me" href=https://github.com/vinidlidoo> <img alt=github loading=lazy src=https://vinidlidoo.github.io/social_icons/github.svg title=github> </a><li><a class="nav-links no-hover-padding social" rel=" me" href=https://x.com/vinidlidoo> <img alt=x loading=lazy src=https://vinidlidoo.github.io/social_icons/x.svg title=x> </a></ul></nav><nav class=nav-navs></nav><div class=credits><small> <p><p>© 2026 Vincent Ethier</p> Powered by <a href=https://www.getzola.org>Zola</a> & <a href=https://github.com/welpo/tabi>tabi</a> </small></div></section><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><h1 class=visually-hidden id=modalTitle>Search</h1><div id=modal-content><div id=searchBar><div aria-hidden=true class=search-icon><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="M784-120 532-372q-30 24-69 38t-83 14q-109 0-184.5-75.5T120-580q0-109 75.5-184.5T380-840q109 0 184.5 75.5T640-580q0 44-14 83t-38 69l252 252-56 56ZM380-400q75 0 127.5-52.5T560-580q0-75-52.5-127.5T380-760q-75 0-127.5 52.5T200-580q0 75 52.5 127.5T380-400Z"/></svg></div><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search… role=combobox spellcheck=false><div class="close-icon interactive-icon" title="Clear search" id=clear-search role=button tabindex=0><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></div></div><div id=results-container><div id=results-info><span id=zero_results> No results</span><span id=one_results> 1 result</span><span id=many_results> $NUMBER results</span><span id=two_results> $NUMBER results</span><span id=few_results> $NUMBER results</span></div><div id=results role=listbox></div></div></div></div></footer>