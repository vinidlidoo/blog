+++
title = "Verkle木：多項式コミットメント（第2回/全2回）"
date = 2026-02-13
description = "たった1つの曲線上の点で256個の子にコミットでき、証明がキロバイトからバイトに縮小する仕組み"

[taxonomies]
tags = ["crypto", "computer-science"]

[extra]
katex = true
social_media_card = "/img/verkle-tree-banner.webp"
+++

![Verkle木：多くのリーフノードから1つの輝くコミットメント点へ収束する滑らかな多項式曲線](/img/verkle-tree-banner.webp)

[第1回](@/blog/ethereum-merkle-patricia-trie.ja.md)はある問題を残して終わった。EthereumのステートトライにおけるMerkle証明はステートレスバリデーションには大きすぎる。ブロックあたり数MBの帯域幅コストでは、証明をブロックに含めると個人バリデータはデータセンターに追いやられてしまう。

解決策は、ハッシュベースのコミットメントを**多項式コミットメント**に置き換えることだ。各ノードがハッシュの代わりに曲線上の点を格納する。違いが現れるのは証明だ。すべての兄弟ハッシュ（約3 KB）を提供する代わりに、証明者は1つの小さな証明（約150バイト）を送るだけでよい。およそ20倍の縮小だ。この記事を読み終えれば、その仕組みがわかるだろう。

## なぜ多項式コミットメントなのか？

Merkle木では、各ノードが子をまとめてハッシュすることでコミットする。

$$H = \text{hash}(\text{child}\_{0}, \text{child}\_{1}, \ldots, \text{child}\_{15})$$

ある子が正しく属していることを確認するには、$H$をゼロから再計算する必要があり、そのためにはすべての兄弟が必要だ。暗号学では、これをコミットメントの**オープン**（開示）と呼ぶ。つまり、値を明かし、それがコミットメントと一致することを証明することだ。ハッシュの場合、1つの子をオープンするには他のすべてを提供しなければならない。各レベルで15個の兄弟ハッシュ、値からルートまで約8〜10レベル分だ。

もし次のようなコミットメント方式があったらどうだろう。

1. コミットメント自体はコンパクト（ハッシュと同程度）
2. 位置 $i$ の子1つに対する証明が、兄弟全体よりはるかに小さい
3. 証明サイズが子の数に応じて増加しない

そうすれば、ノードの幅を16から大幅に広げて、たとえば256にできる。木が浅くなり、証明すべきレベルが減る。

$$C \leftarrow \text{commit}(v\_0, v\_1, \ldots, v\_{255})$$

検証者は小さな証明 $\pi_i$ を $C$ に対して検証するだけで、他の子を見る必要がない。これが**ベクトルコミットメント**であり、Verkleの「V」の由来だ。**V**ector commitment + M**erkle**。[^1] 木の構造は同じで、各ノードのコミットメント方式が異なる。

この考えに初めて出会ったとき、まるで魔法のように感じた。1つの点で256個の値にコミットし、*しかも*他を必要とせずにどれでも証明できるのか？ 答えは多項式だ。見ていこう。

## 値から多項式へ

256個の子すべてを1つの多項式の評価値として表現するのが基本的な考え方だ。多項式はこのような形をしている。

$$P(x) = a_0 + a_1 x + a_2 x^2 + \cdots + a_{255} x^{255}$$

位置 $0, 1, \ldots, 255$ を選び、係数 $a_0, \ldots, a_{255}$ を次のように決める。

$$P(i) = v_i \quad (i = 0, 1, \ldots, 255)$$

これで、すべての子の値を通る次数255の多項式が得られる。このような多項式は常に存在し、一意だ。$n$個の点と値のペアが与えられれば、次数 $n - 1$ の多項式がちょうど1つ決まる。[^2] この多項式を見つけるアルゴリズムが**ラグランジュ補間**だ。

<details>
<summary>ラグランジュ補間の仕組み</summary>

1つの点で1、他のすべての点で0になる「セレクタ」多項式を構築し、それを目的の値で重み付けする。$n$個の点に対して、位置 $j$ の基底多項式は次の通りだ。

$$L_j(x) = \prod_{\substack{m=0 \\\ m \neq j}}^{n-1} \frac{x - m}{j - m}$$

$L_j(j) = 1$ で、$m \neq j$ のすべての $m$ に対して $L_j(m) = 0$ だ。完全な多項式はそれらの重み付き和になる。

$$P(x) = \sum_{i=0}^{n-1} v_i L_i(x)$$

たとえば4つの点の場合、位置0のセレクタは次のようになる。

$$L_0(x) = \frac{(x-1)(x-2)(x-3)}{(0-1)(0-2)(0-3)}$$

$x = 0$ で1、$x = 1, 2, 3$ で0になる。完全な多項式 $P(x) = v_0 L_0(x) + v_1 L_1(x) + v_2 L_2(x) + v_3 L_3(x)$ は4つすべての値を通る。

</details>

ここまではただの代数だ。子をエンコードする多項式が手に入った（Aliceのアカウントデータはある位置にあり、たとえば $P(3) = v_{\text{Alice}}$ とする）。しかし $P$ を直接共有すれば256個の係数すべてを送ることになり、子そのものを送るのと変わらない。$P$ を短いコミットメントに圧縮する方法が必要だ。ここで楕円曲線の出番だ。

## 多項式1つに対して曲線上の点1つ

ここから先のすべての算術（多項式の係数、その評価値、楕円曲線のスカラー）は、同じ[**有限体**](@/blog/math-behind-private-key.ja.md) $\mathbb{F}_p$ 上で行われる。

誰も知らない秘密のスカラー $s$ が存在し、以下の公開された曲線上の点にみんながアクセスできるとしよう。

$$G, \ sG, \ s^2G, \ \ldots, \ s^dG$$

$s$ の生成と破棄については[付録](#trusted-setup)で扱う。ここではこれらの点を所与とする。$P(x)$ にコミットするために、証明者は次を計算する。

$$C = a_0 \cdot G + a_1 \cdot sG + \cdots + a_d \cdot s^dG = P(s) \cdot G$$

証明者は $s$ を知らない。自分の多項式の係数と公開された点を組み合わせるだけだ。[^3] 結果は1つの曲線上の点（BLS12-381で圧縮48バイト）で、多項式全体にコミットする。これは**束縛性**を持つ（ハッシュの衝突耐性に対応する性質だ）。2つの異なる多項式 $P \neq Q$ に対して、$P(s) \neq Q(s)$ が圧倒的な確率で成り立つ。[^4]

Verkleノードは子のkeccak256ハッシュの代わりに $C = P(s) \cdot G$ を格納する。では、他の子を明かさずに1つの子をどう証明するのか。

## 開示証明：1つの値を証明する

Aliceのデータはノード内の位置 $z$ にある。子を多項式の評価値としてエンコードしたので、位置 $z$ の子が値 $y$ であることを証明するのは $P(z) = y$ を証明することと同じだ。検証者はコミットメント $C$ を持っているが、$P$ も他の子も知らない。証明者はどう納得させるのか。

ここがポイントで、多項式の代数から来ている。$P(z) = y$ ならば $P(x) - y$ は $x = z$ に根を持ち、$(x - z)$ で割り切れる。**商多項式**を定義する。

$$Q(x) = \frac{P(x) - y}{x - z}$$

$Q$ が有効な多項式になるのは $P(z) = y$ のときに限る。偽の主張では余りが残り、証明者は有効な $Q$ を生成できない。

**証明は $P$ の代わりに $Q$ へのコミットメントだ。**

$$\pi = Q(s) \cdot G$$

この1つの曲線上の点 $\pi$ が**開示証明**だ。兄弟は不要。

次に検証者は $Q$ が正当かどうかを確認する。除算が割り切れたなら、$P(x) - y = Q(x) \cdot (x - z)$ が多項式の恒等式として成り立つ。したがって $x = s$ を含む任意の点で成り立つ。

$$P(s) - y = Q(s) \cdot (s - z)$$

検証者は2つの曲線上の点を持っている。$C = P(s) \cdot G$ と $\pi = Q(s) \cdot G$ だ。これらはそれぞれ $P(s)$ と $Q(s)$ を隠している。点からスカラーを導出するのは[離散対数問題](@/blog/math-behind-private-key.ja.md)だ。そして $(s - z)$ には $s$ の知識が必要だが、誰もそれを持っていない。

## ペアリングによる証明の検証

**ペアリング** $e$ とは、一方の曲線群（$\mathbb{G}_1$）の点ともう一方（$\mathbb{G}_2$）の点を受け取り、ターゲット群の元を出力する関数で、**双線形性**という性質を持つ。

$$e(aG_1, bG_2) = e(G_1, G_2)^{ab}$$

$a$ を隠す点と $b$ を隠す点を入力すると、出力がそれらの積を捉える。$a$ や $b$ を取り出すことはできないが、2つの積が等しいかどうかをペアリングの出力を比較して確認できる。[^5] ペアリングには2つの異なる曲線群が必要だ。これまで使ってきた $G$ は $\mathbb{G}_1$ に属し（$G_1$ となる）、$G_2$ は $\mathbb{G}_2$ の生成元だ。公開パラメータには $sG_2$ も含まれる。

戦略はこうだ。等式の左辺 $P(s) - y$ を一方のペアリングに入れ、右辺の2つの因子 $Q(s)$ と $(s - z)$ をもう一方に入れる。

左辺：$(P(s) - y)G_1 = C - yG_1$ なので

$$e(C - yG_1, G_2) = e(G_1, G_2)^{P(s) - y}$$

右辺：$Q(s) \cdot G_1 = \pi$ で $(s - z)G_2 = sG_2 - zG_2$ なので

$$e(\pi, sG_2 - zG_2) = e(G_1, G_2)^{Q(s)(s-z)} $$

これらが等しくなるのは $P(s) - y = Q(s)(s - z)$ のとき、すなわち証明したかったことが成り立つときに限る。**検証等式**は次の通りだ。

$$e(C - yG_1, G_2) = e(\pi, sG_2 - zG_2)$$

検証者はこの等式のすべての変数を知っている。$C$ と $\pi$ は証明者から受け取り、$y$ と $z$ は主張された値と位置、$G_1$、$G_2$、$sG_2$ は公開パラメータだ。ペアリングチェック1回、兄弟なし。

## Verkle証明のウォークスルー

木全体を通して完全な証明をたどってみよう。AliceはETH残高を検証したい。Verkle木はEthereumの状態に対して幅256、深さ約3だ。[^6] Aliceのハッシュされたアドレスがパスに対応する。ルート → $C_1$ → $C_2$ → リーフ $v$。証明者はAliceにリーフの値 $v$、中間コミットメント $C_1$ と $C_2$、各レベルの開示証明 $\pi_i$ を送る。Aliceはボトムアップで検証する。

1. $C_2$ は位置 $k_2$ で $v$ にオープンするか？ $\pi_2$ を検証。
2. $C_1$ は位置 $k_1$ で $C_2$ にオープンするか？[^7] $\pi_1$ を検証。
3. $C_0$ は位置 $k_0$ で $C_1$ にオープンするか？ $\pi_0$ を検証。
4. $C_0$ はブロックヘッダのステートルートと一致するか？ 完了。

ペアリングチェック3回、曲線上の点3つ（各約48バイト）、合計約150バイトだ。Merkle木では1レベルあたり15個の兄弟ハッシュ（各32バイト、計480バイト）と比較してほしい。このコミット・オープン・検証方式は**[KZG](https://en.wikipedia.org/wiki/Commitment_scheme#KZG_commitment)**（Kate-Zaverucha-Goldberg）と呼ばれる。Ethereumが使うのはIPAという変種だが（後述）、アーキテクチャは同じだ。ノードごとに1つのコミットメント、レベルごとに1つの証明。数値にするとこうだ。

<img src="/img/merkle-vs-verkle-comparison.webp" alt="MerkleとVerkleの証明構造の比較：Merkleは各レベルで15個の兄弟ハッシュが必要だが、Verkleは各レベルで1つの証明だけで済み、証明サイズが約20分の1になる">

多項式コミットメントは**Merkle木が抱えていたトレードオフも解消する。** Merkle木では幅を狭くすると証明は小さくなる（各レベルの兄弟が減る）が、深い木はルックアップあたりのランダムなディスクリードが増える（[第1回の付録](@/blog/ethereum-merkle-patricia-trie.ja.md)のボトルネック）。Verkle証明のサイズは幅に依存しないため、木を狭く保つ理由がない。ノードあたり256個の子があれば、木は十分浅くなり、ルックアップは3〜4レベルしか触れない。小さな証明*と*高速なディスクアクセスを両立できる。

## EthereumのVerkle提案：IPA

上の数値はKZGの証明サイズを反映している。Ethereumの[Verkle木提案](https://notes.ethereum.org/@vbuterin/verkle_tree_eip)は異なる方式を採用している。**Bandersnatch**曲線上の**IPA**（Inner Product Arguments）で開示する**Pedersenコミットメント**だ。個々の証明はより大きく（約544バイト）、検証はより遅い（子の数に対して対数的で、KZGの定数時間ではない）。その代わり、トラステッドセットアップが不要になる。KZGセットアップの秘密 $s$ が復元されてしまえば、方式全体が崩壊する。Ethereumのすべての価値を恒久的に保全するステートツリーに対して、コミュニティはその前提を完全になくす道を選んだ。ブロックレベルでは、Dankrad Feistの[マルチプルーフ方式](https://dankradfeist.de/ethereum/2021/06/18/pcs-multiproofs.html)がすべての開示証明を1つの定数サイズの証明にまとめ、ブロックあたりのオーバーヘッドを約100〜200 KBの範囲に戻す。

## 今後の展望

この記事を書いている時点で、Verkle木がEthereumに採用されるかどうかは[未決](https://eips.ethereum.org/EIPS/eip-6800)の問題だ。いずれにせよ、ここで築いた考え方（多項式でデータにコミットし、すべてを明かさずに性質を証明する）は、もっと大きなものの基盤になる。**ゼロ知識証明**だ。状態アクセスだけでなく、ブロック全体の実行が正しいことを1つのコンパクトな証明で示す方法を提供する。証明が小さくなればすべてが解決するわけではない（たとえば、増え続ける状態を保存してブロックを構築する人は依然として必要だ）が、方向性は明確だ。証明を増やし、保存を減らす。

ゼロ知識証明の背後にある暗号技術（算術回路から証明システムの違いまで）は、近いうちにこのブログで探っていくつもりだ。楽しみにしていてほしい。

---

## 付録

<a id="trusted-setup"></a>

<details>
<summary>トラステッドセットアップ・セレモニー</summary>

KZGコミットメントには公開パラメータ（曲線上の点 $G, sG, s^2G, \ldots, s^dG$）が必要だ。秘密 $s$ は生成後に破棄しなければならない。誰も知るべきでない数をどうやって破棄するのか。

このセレモニーでは**マルチパーティ計算**を使う。参加者が順番にランダム性を提供する。

1. 参加者1がランダムな $s_1$ を選び、各べき乗 $i$ について $s_1^i G$ を計算し、結果を公開して $s_1$ を破棄する。
2. 参加者2が $s_2$ を選び、前の出力を「再ランダム化」して $(s_1 s_2)^i G$ を生成し、$s_2$ を破棄する。
3. これをすべての参加者について繰り返す。

最終出力は $(s_1 s_2 \cdots s_n)^i G$ だ。結合された秘密 $s = s_1 s_2 \cdots s_n$ は、**少なくとも1人の参加者**が自分の寄与を正直に破棄していれば安全だ。他のすべての参加者が悪意を持っていても、正直な1人がいれば十分だ。

Ethereumは2023年初頭に[EIP-4844](https://eips.ethereum.org/EIPS/eip-4844)（proto-danksharding）のためにまさにこのタイプのセレモニーを実施した。14万人以上が参加し、史上最大のトラステッドセットアップ・セレモニーとなった。得られたパラメータは現在、Ethereum上のblobコミットメントに使われている。

</details>

---

[^1]: この名前と構成はJohn Kuszmaulが[Verkle Trees](https://math.mit.edu/research/highschool/primes/materials/2018/Kuszmaul.pdf)（2018）で導入した。

[^2]: 存在：ラグランジュ補間が $P$ を直接構成する。一意性：$P$ と $Q$ が同じ $n$ 点を通ると仮定する。$D = P - Q$ は $n$ 点すべてでゼロだが、$D$ の次数は高々 $n-1$ なので根は高々 $n-1$ 個。$D = 0$（つまり $P = Q$）でない限り矛盾する。[多項式補間](https://en.wikipedia.org/wiki/Polynomial_interpolation)（一意可解性定理）を参照。

[^3]: スカラー倍が点の加法に分配するためこれが成り立つ。$a_0 \cdot G + a_1 \cdot sG = (a_0 + a_1 s)G$。写像 $f(a) = aG$ はスカラーから曲線上の点への群準同型だ。

[^4]: $P \neq Q$ ならば $D = P - Q$ は次数高々 $d$ の非ゼロ多項式で、$\mathbb{F}_p$ 内に高々 $d$ 個の根を持つ。コミットメントが一致するには、$s$ が $p$ 個のうちの $\leq d$ 個の値のどれかでなければならない。その確率は高々 $d/p$ で、$p \sim 2^{255}$ かつ $d = 255$ なので無視できるほど小さい。

[^5]: ペアリング対応曲線にはこれを可能にする特殊な構造がある。すべての楕円曲線がペアリングをサポートするわけではない。今日Ethereumで使われているBLS12-381は、効率的なペアリングのために特別に設計された。

[^7]: 多項式の評価値はスカラーでなければならないが、$C_2$ と $C_1$ は曲線上の点だ。ブランチノードは各子コミットメントを体の元（たとえばシリアライズされたx座標）に変換してから多項式を補間することで対処する。ステップ3も同様だ。

[^6]: ノードあたり256個の子で、$256^3 \approx 1670$ 万、$256^4 \approx 43$ 億。Ethereumには約2億5000万のアカウントとコントラクトストレージスロットがあるため、深さ3〜4で現在の状態をカバーできる。
