<!doctype html><html lang=ja><head><meta charset=UTF-8><meta content="default-src 'self';font-src 'self' data:;frame-src platform.twitter.com giscus.app;img-src 'self' data: pub-94e31bf482a74272bb61e9559b598705.r2.dev;media-src 'self' pub-94e31bf482a74272bb61e9559b598705.r2.dev;form-action 'self' buttondown.com formspree.io;connect-src 'self';script-src 'self' platform.twitter.com giscus.app" http-equiv=Content-Security-Policy><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://vinidlidoo.github.io name=base><title>
vinidlidoo • EthereumのMerkle Patricia Trie（第1回/全2回）</title><link href=https://vinidlidoo.github.io/img/favicon.png rel=icon type=image/png><link href="https://vinidlidoo.github.io/custom_subset.css?h=0b9535a28bc3d5bf2321" rel=stylesheet><link href="https://vinidlidoo.github.io/main.css?h=045c365e19a4d50a64bb" rel=stylesheet><link href="https://vinidlidoo.github.io/css/details.css?h=8559b4e109b168c7cfa0" rel=stylesheet><link href="https://vinidlidoo.github.io/css/giscus-fix.css?h=dc895b97fbaf0f0d9908" rel=stylesheet><link href="https://vinidlidoo.github.io/css/newsletter.css?h=c872153c9c367e0bee16" rel=stylesheet><link href="https://vinidlidoo.github.io/css/contact.css?h=572915e83e02eb90c290" rel=stylesheet><link href="https://vinidlidoo.github.io/skins/indigo_ingot.css?h=d429472afbb246441b1a" rel=stylesheet><meta content="light dark" name=color-scheme><meta content=Ethereumが状態をどう保存し、1つのハッシュにコミットし、なぜその設計が限界に達しつつあるのか name=description><meta content=Ethereumが状態をどう保存し、1つのハッシュにコミットし、なぜその設計が限界に達しつつあるのか property=og:description><meta content="EthereumのMerkle Patricia Trie（第1回/全2回）" property=og:title><meta content=article property=og:type><meta content="https://vinidlidoo.github.io/img/merkle-patricia-trie-banner.webp?h=7b2b28e3b10def0cf4c6" property=og:image><meta content=1200 property=og:image:width><meta content=670 property=og:image:height><meta content="https://vinidlidoo.github.io/img/merkle-patricia-trie-banner.webp?h=7b2b28e3b10def0cf4c6" name=twitter:image><meta content=summary_large_image name=twitter:card><meta content=en_GB property=og:locale:alternate><link href=https://vinidlidoo.github.io/ja/blog/ethereum-merkle-patricia-trie/ hreflang=ja rel=alternate><meta content=en_GB property=og:locale:alternate><link href=https://vinidlidoo.github.io/blog/ethereum-merkle-patricia-trie/ hreflang=en rel=alternate><meta content=en_GB property=og:locale:alternate><link href=https://vinidlidoo.github.io/fr/blog/ethereum-merkle-patricia-trie/ hreflang=fr rel=alternate><meta content=https://vinidlidoo.github.io/ja/blog/ethereum-merkle-patricia-trie/ property=og:url><meta content=vinidlidoo property=og:site_name><noscript><link href=https://vinidlidoo.github.io/no_js.css rel=stylesheet></noscript><script src=https://vinidlidoo.github.io/js/initializeTheme.min.js></script><script defer src=https://vinidlidoo.github.io/js/themeSwitcher.min.js></script><body><a href=#main-content id=skip-link>Skip to content</a><header><nav class=navbar><div class=nav-title><a class=home-title href=https://vinidlidoo.github.io/ja/>vinidlidoo</a></div><div class=nav-navs><ul><li><a class="nav-links no-hover-padding" href=https://vinidlidoo.github.io/ja/blog/>blog </a><li><a class="nav-links no-hover-padding" href=https://vinidlidoo.github.io/ja/tags/>タグ </a><li><a class="nav-links no-hover-padding" href=https://vinidlidoo.github.io/ja/contact/>連絡先 </a><li class=menu-icons-container><ul class=menu-icons-group><li class=language-switcher><details class=dropdown><summary aria-label="Language selection" title="Language selection" aria-haspopup=true role=button><div class=language-switcher-icon></div></summary> <div class=dropdown-content role=menu>日本語<a aria-label=English href=https://vinidlidoo.github.io/blog/ethereum-merkle-patricia-trie/ lang=en role=menuitem>English</a><a aria-label=Français href=https://vinidlidoo.github.io/fr/blog/ethereum-merkle-patricia-trie/ lang=fr role=menuitem>Français</a></div></details><li class="theme-switcher-wrapper js"><div aria-label="Toggle dark mode" title="Toggle dark/light mode" aria-pressed=false class=theme-switcher role=button tabindex=0></div><div aria-label="Reset mode to default" class="theme-resetter arrow" title="Reset mode to default" aria-hidden=true role=button tabindex=0></div></ul></ul></div></nav></header><div class=content id=main-content><main><article class=h-entry><h1 class="p-name article-title">EthereumのMerkle Patricia Trie（第1回/全2回）</h1><a class="u-url u-uid" href=https://vinidlidoo.github.io/ja/blog/ethereum-merkle-patricia-trie/></a><ul class=meta><span class="hidden p-author h-card"> <a class=u-url href=https://vinidlidoo.github.io rel=author title=Vincent>Vincent</a> </span><li><time class=dt-published datetime=2026-02-03>3rd Feb 2026</time><li title="4450 words"><span aria-hidden=true class=separator>•</span>23 min read<li class=tag><span aria-hidden=true class=separator>•</span>タグ: <li class=tag><a class=p-category href=https://vinidlidoo.github.io/ja/tags/crypto/>crypto</a>, <li class=tag><a class=p-category href=https://vinidlidoo.github.io/ja/tags/computer-science/>computer-science</a></ul><ul class="meta last-updated"><li><time class=dt-updated datetime=2026-02-16>Updated on 16th Feb 2026</time><li><span aria-hidden=true class=separator>•</span><a class=external href=https://github.com/vinidlidoo/vinidlidoo.github.io/commits/main/content/blog/ethereum-merkle-patricia-trie.ja.md>See changes</a></ul><p class=p-summary hidden>Ethereumが状態をどう保存し、1つのハッシュにコミットし、なぜその設計が限界に達しつつあるのか<section class="e-content body"><p><img alt="EthereumのMerkle Patricia Trie" src=/img/merkle-patricia-trie-banner.webp><p>Ethereumは時価総額で2番目に大きいブロックチェーンで、数千億ドル規模の価値を保全している。分散型台帳であることは誰もが知っている。しかし、実際にそのデータをどう保存しているのだろうか。数億のアカウント。独自の永続ストレージを持つスマートコントラクト。トークン残高、NFTの所有記録、DeFiのポジション。250 GBを超える状態が世界中の約100万のバリデータに複製され、日々増え続けている。その答えがMerkle Patricia Trieというデータ構造だ。<p>これはまもなく変わるかもしれない。Ethereumのロードマップは、<strong>ステートレスバリデーション</strong>（完全な状態を保存せずにブロックを検証すること）を実現するために、この構造を置き換えることを目指している。ジェネシス以来最大の構造的変更になるだろう。その理由を理解するには、まず今日のしくみと、それがなぜ限界に達しつつあるのかを知る必要がある。<h2 id=warudosuteto>ワールドステート</h2><p>Ethereumは<strong>ワールドステート</strong>を維持している。つまり、各キーがアドレス、各値がアカウントであるキーバリューストアだ。<p>アカウントには2種類ある。<strong>外部所有アカウント</strong>（EOA）は秘密鍵によって管理され、トランザクションを開始できる。<strong>コントラクトアカウント</strong>はコードを保持し、トランザクションによってトリガーされる。どちらも同じ4つのデータフィールドを共有している。<ul><li><strong>nonce</strong>：トランザクションごとにインクリメントされるカウンタ<li><strong>balance</strong>：保有するネイティブETH<sup class=footnote-reference id=fr-1-1><a href=#fn-1>1</a></sup><li><strong>codeHash</strong>：アカウントのバイトコードのハッシュ（EOAでは空）<li><strong>storageRoot</strong>：コントラクトのストレージを指すハッシュ（EOAでは空）</ul><p>コントラクトではストレージとコードが分離されている。ストレージ（トークン残高、所有記録、設定など）は独自のキーバリューストアに存在し、<code>storageRoot</code>を通じてワールドステートの中にネストされている。コードはオンチェーンに保存されるが、ワールドステートの外にあり、<code>codeHash</code>で参照される。このネストされたストレージについては、Merkle証明のところで改めて取り上げる。<h2 id=nazemu-gou-zao-nanoka>なぜ木構造なのか？</h2><p>一般的なテック企業でこれを構築するなら、おそらく<em>フラットなキーバリューマッピング</em>を使うだろう。アドレスをキーに、アカウントデータを値にする。ルックアップは高速で、更新も簡単で、ツールも成熟している。なぜEthereumにはもっと複雑なものが必要なのか。<p>Ethereumは分散システムだ。約100万のバリデータが同じトランザクションを実行し、同一の状態に到達しなければならない。コンセンサスを検証するために、各ノードは<strong>コミットメント</strong>を生成する。つまり、状態全体を表す短い値だ。現在のEthereumでは32バイトのハッシュがこれにあたる。このコミットメントはブロックヘッダに格納される。自分のものが一致しなければ、状態はネットワークから乖離していることになる。<p>これにより、フラットなキーバリューマッピングでは満たせない2つの要件が生じる。<h3 id=1-xiao-lu-de-nakomitutomento>1. 効率的なコミットメント</h3><p>フラットなマッピングからコミットメントを計算するには、すべてのエントリを何らかの決定的な順序でシリアライズし、まとめてハッシュする必要がある。残高を1つ変更するたびに、状態全体を再シリアライズして再ハッシュしなければならない。250 GB以上のデータに対してブロックごとにO(n)の処理だ。<p>木構造はこれを解決する。各ノードのハッシュは子ノードのハッシュから計算される。リーフを1つ変更すると、ルートまでのパス上のハッシュだけを更新すればよい。O(n)ではなくO(log n)の操作で済む。<h3 id=2-bu-fen-zheng-ming>2. 部分証明</h3><p>Aliceは誰も信頼せずに残高を確認したい。250 GB以上の状態を保存することはできない。フラットなキーバリューストアでは、値を検証する唯一の方法はコミットメントを自分で再計算することだが、それには状態全体が必要だ。<p>木構造はこれも解決する。値の存在を証明するために、証明者はそのリーフからルートまでのパスと、各レベルでハッシュを再計算するのに十分な情報（証明）を提供する。Alice（検証者）はこの小さな証明からルートハッシュを再構築し、既知のルートと照合できる。<h2 id=torai-kiwopasutositeshi-u>トライ：キーをパスとして使う</h2><p>キーバリューストア（アドレス → アカウント）を木構造に整理する必要があることはわかった。では、どうやって？ <strong>トライ</strong>（"try"と発音する。re<strong>trie</strong>valに由来）を使う。<p><strong>トライではキー自体が木のパスになる。</strong> キーの各文字がどの枝に進むかを決定する。<code>4a7f...</code>のような16進キーの場合、ルートから始めて<code>4</code>で分岐し、次に<code>a</code>、次に<code>7</code>、次に<code>f</code>と進み、格納された値に到達する。キーを明示的に保存する必要はない。パスそのもの<em>が</em>キーだ。</p><img alt="A hexary trie where hashed addresses become paths: the root branches on hex digits, and following the digits of a hashed address leads to the account data at the leaves. An extension node compresses a chain of single-child branches into one node (the Patricia optimization)." src=/img/trie-structure.webp><p>Ethereumは<strong>16進トライ</strong>を使う。16進数字（0-F）ごとに1つの子を持ち、最大<strong>幅</strong>は16だ。<strong>深さ</strong>はキーの長さに依存する。挿入前に各アドレスはkeccak256でハッシュされ、32バイトのキー（16進数字で64桁）が生成される。<sup class=footnote-reference id=fr-2-1><a href=#fn-2>2</a></sup> コントラクトのストレージキーも同様にハッシュされる。どちらのトライも最大深さは64だ。Ethereumが使う<strong>Patricia</strong>変種は、子が1つしかないブランチノードをエクステンションノード（上の図の紫色）に圧縮することでトライをコンパクトにする。<h2 id=merkle-patricia-trie>Merkle Patricia Trie</h2><p>トライの構造が整った。次に<strong>Merkle</strong>の部分を追加する。<p>プレーンなPatriciaトライでは、各ノードはキーの16進数字を表す。Merkleトライでは、<strong>各ノードが子のハッシュから計算されたハッシュも持つ</strong>。いずれかのリーフを変更すると、ルートまでのパス上のすべてのノードが新しいハッシュを持つことになる。<p>各ノードのハッシュはどう計算されるのか。ブランチノードの場合、すべての子への参照を結合し、keccak256でハッシュする。出力は1つの32バイトハッシュだ。</p><img alt="Merkle tree showing hash propagation: each parent's hash is computed from its children's hashes, with color-coded levels showing the recursive pattern" src=/img/merkle-hash-propagation.webp><p>ルートハッシュは状態全体にコミットし、すべてのブロックヘッダに格納される。どのバリデータもブロックのトランザクションを実行した後にステートルートを計算し、一致を検証できる。変更されたリーフからルートまでのパスだけを再ハッシュすればよいので、先ほど約束したO(log n)の更新が得られる。つまり、効率的なコミットメントだ。<p>これはどの性質に依存しているのか。<strong>衝突耐性</strong>だ。同じkeccak256ルートを生成する2つの異なる状態を見つけることは計算上実行不可能だ。ルートハッシュは状態を一意に識別する。<p>実際のEthereumの実装はもっと複雑で、ハッシュ前のノードシリアライズにRLPエンコーディングを使い、ノードタイプ（ブランチ、リーフ、エクステンション）ごとに異なる配列仕様があり、偶数/奇数パス長のフラグもある。<details><summary>実装の詳細</summary> <p>トライノードはキーバリューデータベース（歴史的にはLevelDB。現在はクライアントによって異なる）に格納される。各キーはノードのRLPエンコードされた内容のkeccak256ハッシュで、各値はノード自体だ。3つのノードタイプは以下の通り。</p> <ul><li><strong>ブランチ</strong>：17要素の配列 <code>[v0, v1, ..., v15, vt]</code>。各 <code>vi</code> は16進数字 <code>i</code> に対応する子を指す（または空）。<code>vt</code> はキーがここで終端する場合に値を保持する。<li><strong>リーフ</strong>：2要素の配列 <code>[encodedPath, value]</code>。パスは残りのキーニブルをエンコードし、値はアカウントデータだ。<li><strong>エクステンション</strong>：2要素の配列 <code>[encodedPath, nextNode]</code>。子が1つだけのブランチの連鎖を1つのノードに圧縮する（Patricia最適化）。</ul> <p>キーを検索するには、ルートハッシュ（ブロックヘッダ内）から開始し、ルートノードを取得し、次の16進数字に基づいて適切な子をたどり、これを繰り返す。各レベルはランダムなディスクリードになる。<a href=https://ethereum.org/developers/docs/data-structures-and-encoding/patricia-merkle-trie/>Ethereumドキュメント</a>に詳細が記載されている。</p></details><h2 id=merklezheng-ming>Merkle証明</h2><p>先ほど、木構造が部分証明（状態全体なしで単一の値を検証する方法）を可能にすると述べた。仕組みはこうだ。<p>Aliceはスマートフォンのウォレットから自分のEthereum残高を検証したい。完全な状態は250 GB以上で、保存できない。ウォレットは裏で<a href=https://www.infura.io/>Infura</a>や<a href=https://www.alchemy.com/>Alchemy</a>のようなサードパーティのノードプロバイダにクエリするかもしれないが、そのプロバイダが侵害されていたり、嘘をついていたり、ハッキングされている可能性がある。知る術がない。<p>Merkle構造なら別の方法がある。Alice（<strong>検証者</strong>）はブロックヘッダ（各数KB）だけを保存する。<em>任意の</em>フルノード（<strong>証明者</strong>）に残高<em>と証明</em>を要求する。証明からルートを再計算する。ヘッダ内のステートルートと一致すれば、残高は正しい。数学的に保証される。<h3 id=zheng-ming-tojian-zheng>証明と検証</h3><p>深さ $d$ のトライとパス $k = (k_0, k_1, \ldots, k_{d-1})$ を考える。各 $k_i$ はアカウントのハッシュされたキーの16進数字だ。このパスの値を証明するために、証明者は以下を提供する。<ul><li>リーフの値 $v$（4つのアカウントフィールドすべて）<li>各深さ $i$ で最大15個の兄弟ハッシュ $S_i = \lbrace h_{i,j} : j \neq k_i \rbrace$</ul><p>検証はルートをボトムアップで再構築する。リーフをハッシュし、木を上に向かって各レベルで兄弟と結合していく。<p>$$H_d = \text{hash}(v)$$<p>$$H_{i-1} = \text{hash}(h_{i,0} | h_{i,1} | \cdots | h_{i,15})$$<p>$$\text{ただし } h_{i,j} = \left\lbrace \begin{array}{ll} H_i & j = k_{i-1} \text{ のとき} \\ S_i[j] & \text{それ以外} \end{array} \right.$$<p>$H_0$ がステートルートと一致すれば、証明は有効だ。証明者は完全なアカウントを提供しなければならない（いずれかのフィールドが間違っていればリーフハッシュが変わり、証明は失敗する）。しかし検証者は状態の残りを見ることはない。パスに沿った兄弟ハッシュだけだ。</p><img alt="Merkle proof verification: Alice's account is hashed bottom-up through three levels of the hexary trie. At each level, the computed hash (orange) is combined with 15 sibling hashes (green, provided by the prover) to produce the next hash. Gray subtree hints show the rest of the tree that the verifier never needs to see." src=/img/merkle-proof.webp><details><summary>具体的な流れ</summary> <p>Aliceのアドレスをハッシュすると <code>7a4...</code> で始まるキーが得られるとする。簡略化された3レベルのトライでは、パスは $k = (7, a, 4)$ だ。証明にはAliceのアカウントデータと最大45個の兄弟ハッシュ（3レベルそれぞれ15個）が含まれる。検証はボトムアップで進む。</p> <ol><li>アカウントデータをハッシュ → $H_3$<li>$H_3$ を兄弟の中の位置 <code>4</code> に配置し、16個すべてをハッシュ → $H_2$<li>$H_2$ を兄弟の中の位置 <code>a</code> に配置し、16個すべてをハッシュ → $H_1$<li>$H_1$ を兄弟の中の位置 <code>7</code> に配置し、16個すべてをハッシュ → $H_0$<li>確認：$H_0$ はブロックヘッダのステートルートと一致するか？</ol></details><p>コントラクトストレージの値についてはどうだろうか。各アカウントには <code>storageRoot</code> があり、これはそのコントラクトのストレージを含む別のトライのルートであることを思い出してほしい。ストレージの値を証明するには、2つの証明が必要だ。ステートルートからアカウントまでの証明（<code>storageRoot</code>を含む）と、<code>storageRoot</code>からストレージスロットまでの証明だ。同じ検証ロジックが適用されるが、ネストされている。<h2 id=yorixiao-sanazheng-ming-yorida-kinake-neng-xing>より小さな証明、より大きな可能性</h2><p>Aliceは1つの状態値をMerkle証明で検証できる。バリデータもブロックごとに同じようなことを数千回行う。状態を読み取り、トランザクションを実行し、新しいステートルートを計算する。<p>Ethereumの核心的な理念は分散化だ。Vitalik Buterinが<a href=https://decrypt.co/154990/future-ethereum-upgrades-could-allow-full-nodes-to-run-on-mobile-phones-vitalik-buterin>述べたように</a>、「長期的には、完全に検証されたEthereumノードを文字通りスマートフォンで動かせるようにする計画がある」。バリデーションはデータセンターだけでなく、一般的なハードウェアで実行可能であるべきだ。<p>現在、ワールドステートは<a href=https://www.theblock.co/post/383156/ethereum-foundation-researchers-warn-of-storage-burden-from-state-bloat>週に約1ギガバイトのペースで増加している</a>。増大するにつれて、トライのメモリに収まる部分が減り、ランダムなディスクリードが必要なルックアップが増える。<a href=https://vinidlidoo.github.io/ja/blog/understanding-parquet-files/>以前の記事</a>で取り上げたように、ディスク上のデータアクセスはボトルネックを生み出しうる。Ethereumの12秒のスロット制約を満たすには、バリデータにはより高速なストレージ（最低でもSSD、ますますNVMeクラス）が必要になり、コストが上昇して分散化の目標に逆行する。<p>しかし、バリデータが状態をまったく保存しなかったらどうだろう。ディスクから読み取る代わりに、ブロックが触れるすべての値の証明を受け取ることができる。Aliceが使ったのと同じトリックを、スケールアップしたものだ。<p>問題は証明サイズだ。各証明には各レベルで兄弟ハッシュが必要で、15兄弟 × 64レベル × 32バイト ≈ 30 KBが最悪ケース、<a href=https://notes.ethereum.org/@vbuterin/verkle_tree_eip>平均で約3 KB</a>だ。現在のブロックが<a href=https://etherscan.io/chart/gasused>約3000万ガス</a>を使い、コールド状態読み取りに<a href=https://eips.ethereum.org/EIPS/eip-2929>2100ガスかかる</a>ことを考えると、<sup class=footnote-reference id=fr-3-1><a href=#fn-3>3</a></sup> 1ブロックが数千の値に容易にアクセスする。平均約3 KBとして、ブロックあたり数MBの追加帯域幅になる。ブロックあたり10 MBの増分は、バリデータ1台あたり月2 TB以上の追加帯域幅になる。個人ステーカーをデータセンターに追いやるようなオーバーヘッドだ。<p>つまり、証明サイズが律速制約になっている。証明を小さくできれば、ステートレスバリデーションが実現可能になる。<h2 id=ci-hui-yu-gao>次回予告</h2><p>証明を縮小する一つのアプローチは、ハッシュベースのコミットメントを<strong>多項式コミットメント</strong>に置き換えることだ。Verkle木はまさにこれを行い、証明を数KBからそれぞれ150バイト未満に縮小する。Ethereumの状態木は実際には別の方向（耐量子ハッシュベースのコミットメントを用いた<a href=https://eips.ethereum.org/EIPS/eip-7864>バイナリトライ</a>）に進んでいるが、その背後にある暗号技術はきわめて重要だ。多項式コミットメントは<strong>ゼロ知識証明</strong>の基盤であり、ゼロ知識証明は急速に発展中の分野で、Ethereumのスケーリングロードマップをはじめ、その先にも幅広い応用が進んでいる。<a href=https://vinidlidoo.github.io/ja/blog/verkle-trees-polynomial-commitments/>第2回</a>では、<a href=https://vinidlidoo.github.io/ja/blog/math-behind-private-key/>有限体と楕円曲線</a>の上に構築されるVerkle木の仕組みを扱う。<p>状態の増大はもう一つの問題も引き起こす。ステートレスバリデーションによってバリデータは状態の保存を省略できるかもしれないが、ブロックを構築するためには完全な状態がどこかに存在しなければならない。期限付きストレージやUTXOスタイルのレコードといった<a href=https://ethresear.ch/t/hyper-scaling-state-by-creating-new-forms-of-state/24052>新しいストレージプリミティブ</a>が現在議論されており、250 GB超の状態が無限に増え続けるのを食い止められる可能性がある。<hr><h2 id=fu-lu>付録</h2><details><summary>木の形状を変えてMerkle証明を小さくできるか？</summary> <p>木の幅を狭めれば可能だが、現在のアーキテクチャではトレードオフが大きい。トライの各レベルの走査はランダムなディスクリードだ。ルートノードがある場所の子を指し、その子がまた別の場所の子を指す。実効深さ約8〜10の16進トライは、ルックアップごとに8〜10回のランダムリードを意味する。2分木トライの深さは約30〜40になる。NVMe上でもランダムリードは1回あたり数十マイクロ秒かかる。ブロックあたり数千の状態アクセスを掛け合わせると、2分木では12秒のスロットタイムを大幅に超えてしまう。16進分岐は16進エンコードされたキーとの親和性が高く、高速なルックアップに十分な浅さも維持できる。</p> <p>しかもリターンもそれほどよくない。2分木トライは各レベルで15個ではなく1個の兄弟ハッシュしか必要としないが、4倍深くなる（$\log_2 n = 4 \log_{16} n$ なので）。差し引き効果として、1レベルあたりの兄弟が15分の1になる代わりにレベルが4倍になるため、証明は15/4 ≈ 4倍程度の縮小にとどまる。16進証明がブロックあたり約10 MBだとすると、2分木で約2.5 MBになるが、依然として大きなネットワークオーバーヘッドだ。</p> <p>ステートレスバリデーションでは、バリデータがトライを走査するのではなく証明を検証するため、深さはボトルネックでなくなる。ただし、証明サイズのオーバーヘッドは残る。</p></details><hr><section class=footnotes><ol class=footnotes-list><li id=fn-1><p>USDCなど他のトークンはコントラクトストレージで追跡される。 <a href=#fr-1-1>↩</a></p><li id=fn-2><p>keccak256はEthereumのハッシュ関数で、SHA-3として標準化される前のバージョンだ。ハッシュすることで、攻撃者が病的にアンバランスな分岐を作り出すアドレスを意図的に生成することを防いでいる。 <a href=#fr-2-1>↩</a></p><li id=fn-3><p>EIP-2929はコールドリード（初回アクセス、2100ガス）とウォームリード（それ以降、100ガス）を区別する。ここでコールドコストを使うと、実際のアクセス総数を過小評価する。 <a href=#fr-3-1>↩</a></p></ol></section></section><p class=credit><em>この記事は<a href=https://claude.ai>Claude</a>と協力して執筆しました。</em><form action=https://buttondown.com/api/emails/embed-subscribe/vinidlidoo class=embeddable-buttondown-form method=post target=_blank><label for=bd-email>新着記事の通知はこちらから。</label><input id=bd-email name=email placeholder=your@email.com type=email><input type=submit value=登録></form></article></main><link href=https://vinidlidoo.github.io/katex.min.css rel=stylesheet><script defer src=https://vinidlidoo.github.io/js/katex.min.js></script><span class=hidden id=copy-success> Copied! </span><span class=hidden id=copy-init> Copy code to clipboard </span><script defer src=https://vinidlidoo.github.io/js/copyCodeToClipboard.min.js></script></div><footer><section><nav class="socials nav-navs"><ul><li><a class="nav-links no-hover-padding social" rel=" me" href=https://github.com/vinidlidoo> <img alt=github loading=lazy src=https://vinidlidoo.github.io/social_icons/github.svg title=github> </a><li><a class="nav-links no-hover-padding social" rel=" me" href=https://x.com/vinidlidoo> <img alt=x loading=lazy src=https://vinidlidoo.github.io/social_icons/x.svg title=x> </a></ul></nav><nav class=nav-navs></nav><div class=credits><small> <p><p>© 2026 Vincent Ethier</p> Powered by <a href=https://www.getzola.org>Zola</a> & <a href=https://github.com/welpo/tabi>tabi</a> </small></div></section></footer>