<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="default-src 'self';font-src 'self' data:;frame-src platform.twitter.com giscus.app;img-src 'self' data: pub-94e31bf482a74272bb61e9559b598705.r2.dev;media-src 'self' pub-94e31bf482a74272bb61e9559b598705.r2.dev;form-action 'self' buttondown.com formspree.io;connect-src 'self';script-src 'self' platform.twitter.com giscus.app" http-equiv=Content-Security-Policy><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://vinidlidoo.github.io name=base><title>
vinidlidoo • Verkle Trees: Polynomial Commitments (Part 2/2)</title><link href=https://vinidlidoo.github.io/img/favicon.png rel=icon type=image/png><link title="vinidlidoo - Atom Feed" href=https://vinidlidoo.github.io/atom.xml rel=alternate type=application/atom+xml><link href="https://vinidlidoo.github.io/custom_subset.css?h=0b9535a28bc3d5bf2321" rel=stylesheet><link href="https://vinidlidoo.github.io/main.css?h=045c365e19a4d50a64bb" rel=stylesheet><link href="https://vinidlidoo.github.io/css/details.css?h=8559b4e109b168c7cfa0" rel=stylesheet><link href="https://vinidlidoo.github.io/css/giscus-fix.css?h=dc895b97fbaf0f0d9908" rel=stylesheet><link href="https://vinidlidoo.github.io/css/newsletter.css?h=c872153c9c367e0bee16" rel=stylesheet><link href="https://vinidlidoo.github.io/css/contact.css?h=572915e83e02eb90c290" rel=stylesheet><link href="https://vinidlidoo.github.io/skins/indigo_ingot.css?h=d429472afbb246441b1a" rel=stylesheet><meta content="light dark" name=color-scheme><meta content="How a single curve point can commit to 256 children, and why proofs shrink from kilobytes to bytes" name=description><meta content="How a single curve point can commit to 256 children, and why proofs shrink from kilobytes to bytes" property=og:description><meta content="Verkle Trees: Polynomial Commitments (Part 2/2)" property=og:title><meta content=article property=og:type><meta content="https://vinidlidoo.github.io/img/verkle-tree-banner.webp?h=67a03587241b9507a7b1" property=og:image><meta content=1200 property=og:image:width><meta content=670 property=og:image:height><meta content="https://vinidlidoo.github.io/img/verkle-tree-banner.webp?h=67a03587241b9507a7b1" name=twitter:image><meta content=summary_large_image name=twitter:card><meta content=en_GB property=og:locale:alternate><link href=https://vinidlidoo.github.io/blog/verkle-trees-polynomial-commitments/ hreflang=en rel=alternate><meta content=en_GB property=og:locale:alternate><link href=https://vinidlidoo.github.io/fr/blog/verkle-trees-polynomial-commitments/ hreflang=fr rel=alternate><meta content=en_GB property=og:locale:alternate><link href=https://vinidlidoo.github.io/ja/blog/verkle-trees-polynomial-commitments/ hreflang=ja rel=alternate><meta content=https://vinidlidoo.github.io/blog/verkle-trees-polynomial-commitments/ property=og:url><meta content=vinidlidoo property=og:site_name><noscript><link href=https://vinidlidoo.github.io/no_js.css rel=stylesheet></noscript><script src=https://vinidlidoo.github.io/js/initializeTheme.min.js></script><script defer src=https://vinidlidoo.github.io/js/themeSwitcher.min.js></script><script src="https://vinidlidoo.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><a href=#main-content id=skip-link>Skip to content</a><header><nav class=navbar><div class=nav-title><a class=home-title href=https://vinidlidoo.github.io/>vinidlidoo</a></div><div class=nav-navs><ul><li><a class="nav-links no-hover-padding" href=https://vinidlidoo.github.io/blog/>blog </a><li><a class="nav-links no-hover-padding" href=https://vinidlidoo.github.io/tags/>tags </a><li><a class="nav-links no-hover-padding" href=https://vinidlidoo.github.io/contact/>contact </a><li class=menu-icons-container><ul class=menu-icons-group><li class="js menu-icon"><div aria-label="Press $SHORTCUT to open search" class="search-icon interactive-icon" title="Press $SHORTCUT to open search" id=search-button role=button tabindex=0><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="M784-120 532-372q-30 24-69 38t-83 14q-109 0-184.5-75.5T120-580q0-109 75.5-184.5T380-840q109 0 184.5 75.5T640-580q0 44-14 83t-38 69l252 252-56 56ZM380-400q75 0 127.5-52.5T560-580q0-75-52.5-127.5T380-760q-75 0-127.5 52.5T200-580q0 75 52.5 127.5T380-400Z"/></svg></div><li class=language-switcher><details class=dropdown><summary aria-label="Language selection" title="Language selection" aria-haspopup=true role=button><div class=language-switcher-icon></div></summary> <div class=dropdown-content role=menu>English<a aria-label=日本語 href=https://vinidlidoo.github.io/ja/blog/verkle-trees-polynomial-commitments/ lang=ja role=menuitem>日本語</a><a aria-label=Français href=https://vinidlidoo.github.io/fr/blog/verkle-trees-polynomial-commitments/ lang=fr role=menuitem>Français</a></div></details><li class="theme-switcher-wrapper js"><div aria-label="Toggle dark mode" title="Toggle dark/light mode" aria-pressed=false class=theme-switcher role=button tabindex=0></div><div aria-label="Reset mode to default" class="theme-resetter arrow" title="Reset mode to default" aria-hidden=true role=button tabindex=0></div></ul></ul></div></nav></header><div class=content id=main-content><main><article class=h-entry><h1 class="p-name article-title">Verkle Trees: Polynomial Commitments (Part 2/2)</h1><a class="u-url u-uid" href=https://vinidlidoo.github.io/blog/verkle-trees-polynomial-commitments/></a><ul class=meta><span class="hidden p-author h-card"> <a class=u-url href=https://vinidlidoo.github.io rel=author title=Vincent>Vincent</a> </span><li><time class=dt-published datetime=2026-02-13>13th Feb 2026</time><li title="2344 words"><span aria-hidden=true class=separator>•</span>12 min read<li class=tag><span aria-hidden=true class=separator>•</span>Tags: <li class=tag><a class=p-category href=https://vinidlidoo.github.io/tags/crypto/>crypto</a>, <li class=tag><a class=p-category href=https://vinidlidoo.github.io/tags/computer-science/>computer-science</a></ul><ul class="meta last-updated"><li><time class=dt-updated datetime=2026-02-16>Updated on 16th Feb 2026</time><li><span aria-hidden=true class=separator>•</span><a class=external href=https://github.com/vinidlidoo/vinidlidoo.github.io/commits/main/content/blog/verkle-trees-polynomial-commitments.md>See changes</a></ul><p class=p-summary hidden>How a single curve point can commit to 256 children, and why proofs shrink from kilobytes to bytes<section class="e-content body"><p><img alt="Verkle tree: smooth polynomial curves converging from many leaf nodes to a single glowing commitment point" src=/img/verkle-tree-banner.webp><p><a href=https://vinidlidoo.github.io/blog/ethereum-merkle-patricia-trie/>Part 1</a> ended with a problem: Merkle proofs in Ethereum's state trie are too large for stateless validation. At several MB per block, the bandwidth cost of including proofs would push solo validators toward data centers.<p>Verkle trees offer an answer: replace hash-based commitments with <strong>polynomial commitments</strong>. Each node stores a curve point instead of a hash, and nodes widen from 16 children to 256. Instead of proving a leaf by providing every sibling hash on the path to the root (~3 KB), the prover sends a small proof at each level (~150 bytes), roughly 20x smaller. By the end of this post, you'll understand how.<h2 id=from-values-to-a-polynomial>From Values to a Polynomial</h2><p>The central idea is to build a <strong>vector commitment</strong>: a scheme that commits to many values and lets you prove any single one without revealing the others. This is what puts the "V" in Verkle (<strong>V</strong>ector commitment + M<strong>erkle</strong>).<sup class=footnote-reference id=fr-1-1><a href=#fn-1>1</a></sup> Same tree structure, different commitment at each node.<p>We do it with polynomials. Represent all 256 children of a node as evaluations of a single polynomial:<p>$$P(x) = a_0 + a_1 x + a_2 x^2 + \cdots + a_{255} x^{255}$$<p>We pick positions $0, 1, \ldots, 255$ and choose the coefficients $a_0, \ldots, a_{255}$ so that:<p>$$P(i) = v_i \quad \text{for } i = 0, 1, \ldots, 255$$<p>This gives us a degree-255 polynomial that passes through every child value. Such a polynomial always exists and is unique: any $n$ position-value pairs determine exactly one polynomial of degree $n - 1$.<sup class=footnote-reference id=fr-2-1><a href=#fn-2>2</a></sup> The algorithm that finds this polynomial is called <strong>Lagrange interpolation</strong>.<details><summary>How Lagrange interpolation works</summary> <p>The idea: build basis polynomials that each equal 1 at one point and 0 at all others, then take their weighted sum. For $n$ points, the <strong>Lagrange basis</strong> polynomial for position $j$ is:</p> <p>$$L_j(x) = \prod_{\substack{m=0 \\ m \neq j}}^{n-1} \frac{x - m}{j - m}$$</p> <p>$L_j(j) = 1$ and $L_j(m) = 0$ for all $m \neq j$. The full polynomial is their weighted sum:</p> <p>$$P(x) = \sum_{i=0}^{n-1} v_i L_i(x)$$</p> <p>For example, with 4 points, the basis polynomial for position 0 is:</p> <p>$$L_0(x) = \frac{(x-1)(x-2)(x-3)}{(0-1)(0-2)(0-3)}$$</p> <p>This equals 1 when $x = 0$ and 0 at $x = 1, 2, 3$. The full polynomial $P(x) = v_0 L_0(x) + v_1 L_1(x) + v_2 L_2(x) + v_3 L_3(x)$ passes through all four values.</p></details><p>So far this is just algebra. We have a polynomial that encodes the children, but sharing $P$ directly would mean transmitting all 256 coefficients, no better than sending the children themselves. We need a way to compress $P$ into a short commitment. That's where elliptic curves come in.<h2 id=one-curve-point-for-an-entire-polynomial>One Curve Point for an Entire Polynomial</h2><p>Heads up: all arithmetic from here on (the polynomial's coefficients, its evaluations, the elliptic curve's scalars) happens over the same <a href=https://vinidlidoo.github.io/blog/math-behind-private-key/#fields-numbers-with-arithmetic><strong>finite field</strong></a> $\mathbb{F}_p$.<p>Suppose there's a secret scalar $s$ that nobody knows, but everyone has access to the following <strong>public parameters</strong>:<p>$$G, \ sG, \ s^2G, \ \ldots, \ s^dG$$<p>How $s$ is generated and destroyed is covered in the <a href=https://vinidlidoo.github.io/blog/verkle-trees-polynomial-commitments/#trusted-setup>Appendix</a>. For now, take these points as given. To commit to $P(x)$, the prover computes:<p>$$\begin{aligned} C &= a_0 \cdot G + a_1 \cdot sG + \cdots + a_d \cdot s^dG \\ &= P(s) \cdot G \end{aligned}$$<p>Note that the prover doesn't need $s$ to compute $C$: they just combine their polynomial's coefficients with the public parameters.<sup class=footnote-reference id=fr-3-1><a href=#fn-3>3</a></sup><p>The result is a single curve point (48 bytes compressed) that commits to the entire polynomial. Just as a collision-resistant hash won't produce the same output for two different inputs, this commitment is <strong>binding</strong>: two different polynomials $P \neq Q$ satisfy $P(s) \neq Q(s)$ with overwhelming probability, so their commitments $C = P(s) \cdot G$ are distinct.<sup class=footnote-reference id=fr-4-1><a href=#fn-4>4</a></sup><p>Each Verkle node now stores this $C$ instead of a hash. We have the commitment; now we need a way to prove what's inside it.<h2 id=opening-proofs-proving-a-single-value>Opening Proofs: Proving a Single Value</h2><p>Alice wants to <strong>open</strong> the commitment $C$ at position $z$ to verify it holds value $y$. The prover must convince her that $P(z) = y$ without revealing $P$ or any other child. How?<p>The key insight comes from polynomial algebra: if $P(z) = y$, then $P(x) - y$ has a root at $x = z$, so $(x - z)$ divides it evenly. We define the <strong>quotient polynomial</strong>:<p>$$Q(x) = \frac{P(x) - y}{x - z}$$<p>This division is exact if and only if $P(z) = y$. A false claim leaves a remainder, so the prover can't produce a valid $Q$.<p>The <strong>opening proof</strong> $\pi$ is simply a commitment to $Q$:<p>$$\pi = Q(s) \cdot G$$<p>One curve point. No siblings needed.<p>Now the verifier needs to check that $Q$ is legitimate. If the division was exact, multiplying back gives a polynomial identity that holds at every point, including $x = s$:<p>$$P(s) - y = Q(s) \cdot (s - z) \tag{1}$$<p>The verifier can't check this equation directly. They have $C = P(s) \cdot G$ and $\pi = Q(s) \cdot G$, but the curve points <strong>hide</strong> their scalars: extracting $P(s)$ or $Q(s)$ from them is the <a href=https://vinidlidoo.github.io/blog/math-behind-private-key/>discrete logarithm problem</a>. And $(s - z)$ requires knowing $s$, which nobody has.<h2 id=verifying-the-proof-with-pairings>Verifying the Proof with Pairings</h2><p>A <strong>pairing</strong> $e$ is a function that takes a point from one curve group ($\mathbb{G}_1$) and a point from another ($\mathbb{G}_2$) and outputs an element in a target group, with the property of <strong>bilinearity</strong>:<p>$$e(aG_1, bG_2) = e(G_1, G_2)^{ab}$$<p>Feed in a point hiding some scalar $a$ and another hiding $b$, and the output captures their product. We can't extract $a$ or $b$, but we can check whether <strong>two products are equal</strong> by comparing pairing outputs.<sup class=footnote-reference id=fr-5-1><a href=#fn-5>5</a></sup> Pairings require two distinct curve groups; the $G$ we've been using lives in $\mathbb{G}_1$ (becoming $G_1$), and $G_2$ is a generator in $\mathbb{G}_2$. The public parameters also include $sG_2$.<p>The strategy: express each side of equation $(1)$ as a product of two scalars, then feed one factor into $\mathbb{G}_1$ and the other into $\mathbb{G}_2$. The right side naturally factors as $Q(s) \cdot (s - z)$. The left side is just $(P(s) - y) \cdot 1$, so we pair it with the plain generator $G_2$:<p><strong>Left side</strong>: $(P(s) - y)G_1 = C - yG_1$, so<p>$$e(C - yG_1, G_2) = e(G_1, G_2)^{P(s) - y}$$<p><strong>Right side</strong>: $Q(s) \cdot G_1 = \pi$ and $(s - z)G_2 = sG_2 - zG_2$, so<p>$$e(\pi, sG_2 - zG_2) = e(G_1, G_2)^{Q(s)(s-z)} $$<p>These are equal if and only if equation $(1)$ holds, so verification reduces to a single check:<p>$$e(C - yG_1, G_2) = e(\pi, sG_2 - zG_2) \tag{2}$$<p>The verifier knows every variable in this equation: $C$ and $\pi$ came from the prover, $y$ and $z$ are the claimed value and position, and $G_1$, $G_2$, $sG_2$ are public parameters. One pairing check, no siblings.<h2 id=putting-it-all-together>Putting It All Together</h2><p>Step back and consider what we just built. A node with 256 children gets encoded as a polynomial and mapped to a single curve point. To open one child, the prover divides out the corresponding root, producing a quotient polynomial, and maps it to a second curve point. A pairing function then reaches across two curve groups and, through bilinearity, verifies the division was exact from the curve points alone. Two points, one check, done. That this works at all feels like reaching through a crack in the universe.<p>This commit-open-verify scheme is called <strong><a href=https://en.wikipedia.org/wiki/Commitment_scheme#KZG_commitment>KZG</a></strong> (Kate-Zaverucha-Goldberg): produce one commitment per node, one opening proof per level. A Merkle tree with width 16 needs ~8-10 levels and 15 sibling hashes (480 bytes) at each one. A Verkle tree with width 256 covers the same state in just ~3 levels,<sup class=footnote-reference id=fr-6-1><a href=#fn-6>6</a></sup> with a single ~48-byte proof at each:</p><img alt="Side-by-side comparison of Merkle vs Verkle proof structure: Merkle needs 15 sibling hashes per level while Verkle needs only one proof per level, resulting in ~20x smaller proofs" src=/img/merkle-vs-verkle-comparison.webp><details><summary>Walkthrough</summary> <p>Alice wants to verify her ETH balance. Her hashed address gives the positions $k_0, k_1, k_2$ that trace a path: root $\to$ $C_1$ $\to$ $C_2$ $\to$ leaf $v$. The prover sends Alice the leaf value $v$, the intermediate commitments $C_1$ and $C_2$, and an opening proof $\pi_i$ at each level. Alice verifies bottom-up:</p> <ol><li>Does $C_2$ open at position $k_2$ to $v$? Check $\pi_2$.<li>Does $C_1$ open at position $k_1$ to $C_2$?<sup class=footnote-reference id=fr-7-1><a href=#fn-7>7</a></sup> Check $\pi_1$.<li>Does $C_0$ open at position $k_0$ to $C_1$? Check $\pi_0$.<li>Does $C_0$ match the state root in the block header? Done.</ol> <p>That's three opening proofs (~48 bytes each), about 150 bytes total.</p></details><p>Polynomial commitments also <strong>remove a tradeoff that hash-based Merkle proofs face.</strong> In a Merkle tree, narrower means smaller proofs (fewer siblings per level), but deeper means more disk reads per lookup (the bottleneck from <a href=https://vinidlidoo.github.io/blog/ethereum-merkle-patricia-trie/#appendix>Part 1's appendix</a>). Stateless validation eases the depth side, but proof size still grows with width. With polynomial commitments, it doesn't: nodes can be wide and the tree shallow.<h2 id=ethereum-s-verkle-proposal-ipa>Ethereum's Verkle Proposal: IPA</h2><p>The figures above reflect KZG proof sizes. Ethereum's <a href=https://notes.ethereum.org/@vbuterin/verkle_tree_eip>Verkle tree proposal</a> swapped in different building blocks: a different commitment type (<strong>Pedersen</strong>), proof technique (<strong>IPA</strong>), and curve (<strong>Bandersnatch</strong>). The architecture is the same; individual proofs are larger (~544 bytes) and verification slower, but the tradeoff worth it: no trusted setup. If the secret $s$ in a KZG ceremony were ever reconstructed, the entire scheme would break. For a state tree securing all of Ethereum's value, the community preferred eliminating that risk entirely.<p>At block level, Dankrad Feist's <a href=https://dankradfeist.de/ethereum/2021/06/18/pcs-multiproofs.html>multiproof scheme</a> merges all opening proofs across a block into a single constant-size proof (~200 bytes), regardless of how many state accesses the block contains.<h2 id=what-s-next>What's Next</h2><p>Verkle trees now look unlikely to make it into Ethereum: their reliance on elliptic curve cryptography isn't quantum-resistant, and the community is leaning toward a <a href=https://eips.ethereum.org/EIPS/eip-7864>hash-based binary state tree</a> instead. The ideas we built here (committing to data with polynomials, proving properties without revealing everything), though, are foundational to something bigger: <strong>zero-knowledge proofs</strong>. They provide a way to prove not only state access, but that an entire block's execution was correct in a single, compact proof. Smaller proofs don't solve every problem (e.g., someone still has to store the ever-growing state to construct blocks), but increasingly, the goal is to prove more and store less.<p>The cryptography behind zero-knowledge proofs, from arithmetic circuits to the difference between proof systems, is something I'll explore on this blog soon. Stay tuned.<hr><h2 id=appendix>Appendix</h2><p><a id=trusted-setup></a><details><summary>The Trusted Setup Ceremony</summary> <p>KZG commitments require public parameters: the curve points $G, sG, s^2G, \ldots, s^dG$. The secret $s$ must be destroyed after generation. How do you destroy a number that nobody should ever know?</p> <p>The ceremony uses <strong>multi-party computation</strong>. Participants contribute randomness sequentially:</p> <ol><li>Participant 1 picks a random $s_1$, computes $s_1^i G$ for each power $i$, publishes the result, and destroys $s_1$.<li>Participant 2 picks $s_2$, "re-randomizes" the previous output to produce $(s_1 s_2)^i G$, and destroys $s_2$.<li>This continues for all participants.</ol> <p>The final output is $(s_1 s_2 \cdots s_n)^i G$. The combined secret $s = s_1 s_2 \cdots s_n$ is secure as long as <strong>at least one participant</strong> honestly destroyed their contribution. Even if every other participant is malicious, one honest party is enough.</p> <p>Ethereum ran exactly this kind of ceremony for <a href=https://eips.ethereum.org/EIPS/eip-4844>EIP-4844</a> (proto-danksharding) in early 2023. Over 140,000 participants contributed, making it the largest trusted setup ceremony ever. The resulting parameters are used for blob commitments on Ethereum today.</p></details><hr><section class=footnotes><ol class=footnotes-list><li id=fn-1><p>The name and construction were introduced by John Kuszmaul in <a href=https://math.mit.edu/research/highschool/primes/materials/2018/Kuszmaul.pdf>Verkle Trees</a> (2018). <a href=#fr-1-1>↩</a></p><li id=fn-2><p>Existence: Lagrange interpolation constructs $P$ directly. Uniqueness: suppose $P$ and $Q$ both pass through the same $n$ points. Then $D = P - Q$ is zero at all $n$ points, but $D$ has degree at most $n-1$, so at most $n-1$ roots. Contradiction unless $D = 0$, i.e., $P = Q$. See <a href=https://en.wikipedia.org/wiki/Polynomial_interpolation>Polynomial interpolation</a> (Unisolvence Theorem). <a href=#fr-2-1>↩</a></p><li id=fn-3><p>This works because scalar multiplication distributes over point addition: $a_0 \cdot G + a_1 \cdot sG = (a_0 + a_1 s)G$. The map $f(a) = aG$ is a group homomorphism from scalars to curve points. <a href=#fr-3-1>↩</a></p><li id=fn-4><p>If $P \neq Q$, then $D = P - Q$ is a non-zero polynomial of degree at most $d$, so it has at most $d$ roots in $\mathbb{F}_p$. For the commitments to collide, $s$ would have to be one of those $\leq d$ values out of $p$ total. That probability is at most $d/p$, which is negligible since $p \sim 2^{255}$ and $d = 255$. <a href=#fr-4-1>↩</a></p><li id=fn-5><p>Pairing-friendly curves have special structure that enables this. Not all elliptic curves support pairings. BLS12-381, used in Ethereum today, was designed specifically for efficient pairings. <a href=#fr-5-1>↩</a></p><li id=fn-6><p>With 256 children per node, $256^3 \approx 16.7$ million and $256^4 \approx 4.3$ billion. Ethereum has roughly 250 million accounts plus contract storage slots, so depth 3-4 covers the current state. <a href=#fr-6-1>↩</a></p><li id=fn-7><p>Polynomial evaluations must be scalars, but $C_2$ and $C_1$ are curve points. Branch nodes handle this by mapping each child commitment to a field element (e.g., its serialized x-coordinate) before interpolating the polynomial. The same applies to step 3. <a href=#fr-7-1>↩</a></p></ol></section></section><p class=credit><em>This post was written in collaboration with <a href=https://claude.ai>Claude</a>.</em><form action=https://buttondown.com/api/emails/embed-subscribe/vinidlidoo class=embeddable-buttondown-form method=post target=_blank><label for=bd-email>Get notified when I post something new.</label><input id=bd-email name=email placeholder=your@email.com type=email><input type=submit value=Subscribe></form></article></main><link href=https://vinidlidoo.github.io/katex.min.css rel=stylesheet><script defer src=https://vinidlidoo.github.io/js/katex.min.js></script><span class=hidden id=copy-success> Copied! </span><span class=hidden id=copy-init> Copy code to clipboard </span><script defer src=https://vinidlidoo.github.io/js/copyCodeToClipboard.min.js></script></div><footer><section><nav class="socials nav-navs"><ul><li><a class="nav-links no-hover-padding social" href=https://vinidlidoo.github.io/atom.xml> <img alt=feed loading=lazy src=https://vinidlidoo.github.io/social_icons/rss.svg title=feed> </a><li><a class="nav-links no-hover-padding social" rel=" me" href=https://github.com/vinidlidoo> <img alt=github loading=lazy src=https://vinidlidoo.github.io/social_icons/github.svg title=github> </a><li><a class="nav-links no-hover-padding social" rel=" me" href=https://x.com/vinidlidoo> <img alt=x loading=lazy src=https://vinidlidoo.github.io/social_icons/x.svg title=x> </a></ul></nav><nav class=nav-navs></nav><div class=credits><small> <p><p>© 2026 Vincent Ethier</p> Powered by <a href=https://www.getzola.org>Zola</a> & <a href=https://github.com/welpo/tabi>tabi</a> </small></div></section><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><h1 class=visually-hidden id=modalTitle>Search</h1><div id=modal-content><div id=searchBar><div aria-hidden=true class=search-icon><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="M784-120 532-372q-30 24-69 38t-83 14q-109 0-184.5-75.5T120-580q0-109 75.5-184.5T380-840q109 0 184.5 75.5T640-580q0 44-14 83t-38 69l252 252-56 56ZM380-400q75 0 127.5-52.5T560-580q0-75-52.5-127.5T380-760q-75 0-127.5 52.5T200-580q0 75 52.5 127.5T380-400Z"/></svg></div><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search… role=combobox spellcheck=false><div class="close-icon interactive-icon" title="Clear search" id=clear-search role=button tabindex=0><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></div></div><div id=results-container><div id=results-info><span id=zero_results> No results</span><span id=one_results> 1 result</span><span id=many_results> $NUMBER results</span><span id=two_results> $NUMBER results</span><span id=few_results> $NUMBER results</span></div><div id=results role=listbox></div></div></div></div></footer>