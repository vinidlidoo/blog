<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="default-src 'self';font-src 'self' data:;frame-src platform.twitter.com giscus.app;img-src 'self' data: pub-94e31bf482a74272bb61e9559b598705.r2.dev;media-src 'self' pub-94e31bf482a74272bb61e9559b598705.r2.dev;form-action 'self' buttondown.com formspree.io;connect-src 'self';script-src 'self' platform.twitter.com giscus.app" http-equiv=Content-Security-Policy><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://vinidlidoo.github.io name=base><title>
vinidlidoo • The Limits of Computation (Part 3/3)</title><link href=https://vinidlidoo.github.io/img/favicon.png rel=icon type=image/png><link title="vinidlidoo - Atom Feed" href=https://vinidlidoo.github.io/atom.xml rel=alternate type=application/atom+xml><link href="https://vinidlidoo.github.io/custom_subset.css?h=0b9535a28bc3d5bf2321" rel=stylesheet><link href="https://vinidlidoo.github.io/main.css?h=045c365e19a4d50a64bb" rel=stylesheet><link href="https://vinidlidoo.github.io/css/details.css?h=8559b4e109b168c7cfa0" rel=stylesheet><link href="https://vinidlidoo.github.io/css/giscus-fix.css?h=dc895b97fbaf0f0d9908" rel=stylesheet><link href="https://vinidlidoo.github.io/css/newsletter.css?h=c872153c9c367e0bee16" rel=stylesheet><link href="https://vinidlidoo.github.io/css/contact.css?h=572915e83e02eb90c290" rel=stylesheet><link href="https://vinidlidoo.github.io/skins/indigo_ingot.css?h=d429472afbb246441b1a" rel=stylesheet><meta content="light dark" name=color-scheme><meta content="What Turing machines can't do, and why it matters" name=description><meta content="What Turing machines can't do, and why it matters" property=og:description><meta content="The Limits of Computation (Part 3/3)" property=og:title><meta content=article property=og:type><meta content=en_GB property=og:locale:alternate><link href=https://vinidlidoo.github.io/blog/limits-of-computation/ hreflang=en rel=alternate><meta content=en_GB property=og:locale:alternate><link href=https://vinidlidoo.github.io/fr/blog/limits-of-computation/ hreflang=fr rel=alternate><meta content=en_GB property=og:locale:alternate><link href=https://vinidlidoo.github.io/ja/blog/limits-of-computation/ hreflang=ja rel=alternate><meta content=https://vinidlidoo.github.io/blog/limits-of-computation/ property=og:url><meta content=vinidlidoo property=og:site_name><noscript><link href=https://vinidlidoo.github.io/no_js.css rel=stylesheet></noscript><script src=https://vinidlidoo.github.io/js/initializeTheme.min.js></script><script defer src=https://vinidlidoo.github.io/js/themeSwitcher.min.js></script><script src="https://vinidlidoo.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><a href=#main-content id=skip-link>Skip to content</a><header><nav class=navbar><div class=nav-title><a class=home-title href=https://vinidlidoo.github.io/>vinidlidoo</a></div><div class=nav-navs><ul><li><a class="nav-links no-hover-padding" href=https://vinidlidoo.github.io/blog/>blog </a><li><a class="nav-links no-hover-padding" href=https://vinidlidoo.github.io/tags/>tags </a><li><a class="nav-links no-hover-padding" href=https://vinidlidoo.github.io/contact/>contact </a><li class=menu-icons-container><ul class=menu-icons-group><li class="js menu-icon"><div aria-label="Press $SHORTCUT to open search" class="search-icon interactive-icon" title="Press $SHORTCUT to open search" id=search-button role=button tabindex=0><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="M784-120 532-372q-30 24-69 38t-83 14q-109 0-184.5-75.5T120-580q0-109 75.5-184.5T380-840q109 0 184.5 75.5T640-580q0 44-14 83t-38 69l252 252-56 56ZM380-400q75 0 127.5-52.5T560-580q0-75-52.5-127.5T380-760q-75 0-127.5 52.5T200-580q0 75 52.5 127.5T380-400Z"/></svg></div><li class=language-switcher><details class=dropdown><summary aria-label="Language selection" title="Language selection" aria-haspopup=true role=button><div class=language-switcher-icon></div></summary> <div class=dropdown-content role=menu>English<a aria-label=Français href=https://vinidlidoo.github.io/fr/blog/limits-of-computation/ lang=fr role=menuitem>Français</a><a aria-label=日本語 href=https://vinidlidoo.github.io/ja/blog/limits-of-computation/ lang=ja role=menuitem>日本語</a></div></details><li class="theme-switcher-wrapper js"><div aria-label="Toggle dark mode" title="Toggle dark/light mode" aria-pressed=false class=theme-switcher role=button tabindex=0></div><div aria-label="Reset mode to default" class="theme-resetter arrow" title="Reset mode to default" aria-hidden=true role=button tabindex=0></div></ul></ul></div></nav></header><div class=content id=main-content><main><article class=h-entry><h1 class="p-name article-title">The Limits of Computation (Part 3/3)</h1><a class="u-url u-uid" href=https://vinidlidoo.github.io/blog/limits-of-computation/></a><ul class=meta><span class="hidden p-author h-card"> <a class=u-url href=https://vinidlidoo.github.io rel=author title=Vincent>Vincent</a> </span><li><time class=dt-published datetime=2026-01-11>11th Jan 2026</time><li title="1379 words"><span aria-hidden=true class=separator>•</span>7 min read<li class=tag><span aria-hidden=true class=separator>•</span>Tags: <li class=tag><a class=p-category href=https://vinidlidoo.github.io/tags/math/>math</a>, <li class=tag><a class=p-category href=https://vinidlidoo.github.io/tags/computer-science/>computer-science</a></ul><p class=p-summary hidden>What Turing machines can't do, and why it matters<section class="e-content body"><p>In <a href=https://vinidlidoo.github.io/blog/turing-completeness/>Part 2</a>, we established that Turing completeness is the ceiling of computational power. Every reasonable formalism for "computation" turns out to be equivalent. You can't build something stronger than a Turing machine.<p>But can Turing machines solve <em>everything</em>?<p>No. And the proof is surprisingly elegant. It will also lead us, almost immediately, to one of the most famous results in mathematics: Gödel's Incompleteness Theorem.<h2 id=the-halting-problem>The Halting Problem</h2><p>Here's a simple question: given a program, will it ever finish running? In our formalism from <a href=https://vinidlidoo.github.io/blog/turing-machines/>Part 1</a>, a "program" is an encoding $\langle M, w \rangle$: a Turing machine $M$ together with its input $w$, written as data on a tape. So the halting question is: does $M$ halt on $w$?<p>Imagine a <em>Halt Decider</em>, $H$. Feed it your code and it tells you "this terminates (halts)" or "this loops forever." If it existed, you could use it on any program to catch infinite loops before deployment, verify that critical software always returns an answer, guarantee any recursive function won't recurse forever. Incredibly useful.<p>The <strong>Halting Problem</strong> asks: can we build such $H$? Not for one specific program, but a general procedure that correctly answers for <em>all</em> $\langle M, w \rangle$.<p>Turing proved no such procedure can exist.<h2 id=intuition>Intuition</h2><p>It's useful to notice that "yes" and "no" answers to the halting question are fundamentally different.<p>For "yes" answers, just run the program long enough. If it halts after a week, you can say confidently "yes, it halts."<p>"no" answers are different. Suppose you've been running a program for a thousand years and it still hasn't halted. Can you say "no, it won't ever halt"? You can't. Maybe it'll halt in a thousand and one years. At no point does running the program entitle you to say "no."<p>This asymmetry hints at the impossibility. Let's now prove it.<h2 id=the-diagonal-argument>The Diagonal Argument</h2><p>Suppose, toward contradiction, that we have a procedure $H$ that solves the halting problem. Given any program $P$ and input, $H$ correctly tells us whether $P$ halts.<p>Now I'll use $H$ as a subroutine to build a new program. Call it $Q$. Program $Q$ takes another program $P$ as input and does the following:<ol><li>Ask $H$: "Would $P$ halt if we ran it on $P$ itself?"<li>If $H$ says "yes, $P$ halts on $P$" → $Q$ loops forever<li>If $H$ says "no, $P$ doesn't halt on $P$" → $Q$ halts immediately</ol><p>That's it. $Q$ asks whether $P$ halts on itself, then does the <em>opposite</em>.<p>Step 1 is the diagonal part: we're feeding $P$ its own description as input. This is the same self-referential trick behind <a href=https://vinidlidoo.github.io/blog/russells-paradox/>Russell's paradox</a> and Cantor's diagonal argument we explored in <a href=https://vinidlidoo.github.io/blog/three-proofs-by-diagonalization/>Three Proofs by Diagonalization</a>.<p>Now comes the punch line. $Q$ is a program. What happens when we run $Q$ on <em>itself</em>?<ul><li>If $Q$ halts on $Q$, then $H$ must have said "$Q$ halts on $Q$," so by step 2, $Q$ loops forever. Contradiction.<li>If $Q$ doesn't halt on $Q$, then $H$ must have said "$Q$ doesn't halt on $Q$," so by step 3, $Q$ halts. Contradiction.</ul><p>$Q$ halts on $Q$ if and only if $Q$ doesn't halt on $Q$. That's impossible. So $H$ cannot exist.<p>The halting problem is <strong>undecidable</strong>. $\blacksquare$<h2 id=why-this-matters>Why This Matters</h2><p>What does "undecidable" mean? <strong>A problem is decidable if there exists a procedure that always halts and always gives the correct yes/no answer.</strong> The halting problem is undecidable: no such procedure exists. For any would-be halt decider, there's some program it gets wrong (or runs forever on).<p>The halting problem might seem like a contrived edge case. But it is only the tip of the iceberg. <a href=https://en.wikipedia.org/wiki/Rice%27s_theorem>Rice's Theorem</a>, proved in 1953 by Henry Gordon Rice, generalized it: <em>any</em> non-trivial property of what a program computes is undecidable. Want to know if a program ever outputs a specific value? Undecidable. Ever accesses the network? Undecidable. Contains a security vulnerability? Undecidable.<p>This explains why static analysis tools sometimes produce false positives, why compilers can't always eliminate dead code, and why antivirus software can't catch all malware. Perfect program analysis is mathematically impossible.<h2 id=godel-s-incompleteness-theorem>Gödel's Incompleteness Theorem</h2><p>The halting problem immediately proves one of the most famous results in mathematics.<p>In the early 20th century, David Hilbert proposed an ambitious goal: find a finite set of axioms from which every true statement about numbers could be mechanically derived. Start with basic axioms like "$0$ is a number" and "$x + 0 = x$," add rules of inference, and in principle you could prove any true arithmetic statement.<p>Here we need to distinguish two concepts:<ul><li>A statement is <strong>true</strong> if it accurately describes actual numbers (e.g., "there is no largest prime")<li>A statement is <strong>provable</strong> if it can be derived from axioms via inference rules</ul><p>These aren't obviously the same thing. Truth is about what's actually the case; provability is about what follows from your starting assumptions. Hilbert's dream, called <strong>Hilbert's program</strong>, was to make them coincide for arithmetic: every true statement should be provable, and every provable statement should be true.<sup class=footnote-reference id=fr-1-1><a href=#fn-1>1</a></sup><p>If such a system existed, you could build a theorem-proving machine: start from the axioms, apply inference rules in every possible way, and output each theorem as you derive it.<sup class=footnote-reference id=fr-2-1><a href=#fn-2>2</a></sup> $1 + 1 = 2$. Every prime has a larger prime. One by one, every true statement about numbers.<p>Here's the key insight: <strong>such a machine would solve the halting problem.</strong> Whether a program halts is a question about finite sequences of state transitions—exactly the kind of thing arithmetic can express. If the axiom system were complete, then for any program $M$ and input $w$, either "$M$ halts on $w$" or "$M$ doesn't halt on $w$" would be provable. The enumeration machine would eventually find whichever proof exists, and we'd have our answer.<p>But we already proved the halting problem is undecidable. So the system cannot be complete.<blockquote><p><strong>Gödel's First Incompleteness Theorem</strong>: Any computable axiom system<sup class=footnote-reference id=fr-3-1><a href=#fn-3>3</a></sup> capable of expressing basic arithmetic is incomplete. There exist true statements that the system cannot prove.</blockquote><p>This is the punchline: <strong>truth outruns provability.</strong> No matter what axioms you choose, some statements will be <em>independent</em>—neither provable nor refutable within the system.<h2 id=takeaway>Takeaway</h2><p>We've traced a boundary between what's computable and what isn't. In Part 2, we saw that Turing completeness is the ceiling: you can't compute more than a Turing machine can. But now we've seen that this ceiling has holes. Some problems have no procedure that always halts with the correct answer.<p><strong>Inside</strong>: any yes/no problem for which we can write a terminating procedure. Is this number prime? Trial division will tell you. What's 347 × 892? Long multiplication gives the answer. Sort this list? Mergesort terminates with the correct ordering. These are decidable: we have procedures that always halt with correct answers.<p><strong>Outside</strong>: the halting problem is just the beginning. Rice's theorem tells us that <em>any</em> interesting question about program behavior is undecidable. Does this code have a bug? Will it ever access the network? Is it equivalent to this other program? No single general algorithm can answer these for <strong>all programs</strong>. And Gödel tells us the problem runs deeper: some true statements about numbers can never be proven from any finite set of axioms.<p>This boundary doesn't depend on technology. Faster computers, quantum computers, whatever comes next: the halting problem will still be undecidable, and arithmetic will still be incomplete. There are truths that no mechanical procedure can discover. That's a deep fact about the nature of computation itself.<hr><section class=footnotes><ol class=footnotes-list><li id=fn-1><p>The second half—every provable statement is true—is called <em>soundness</em>, and we definitely want it. An unsound system proves false things, which is useless. The first half—every true statement is provable—is called <em>completeness</em>. Gödel showed completeness is impossible. <a href=#fr-1-1>↩</a></p><li id=fn-2><p>Why can we enumerate theorems? A proof is a finite sequence of steps, each following mechanically from axioms or previous steps. Enumerate all finite sequences, check each for validity, output the conclusion of valid proofs. Every provable statement eventually appears. <a href=#fr-2-1>↩</a></p><li id=fn-3><p>The system must also be <em>consistent</em>: it never proves both $P$ and $\neg P$. An inconsistent system can prove anything (including contradictions), making "completeness" trivially achievable but meaningless. <a href=#fr-3-1>↩</a></p></ol></section></section><p class=credit><em>This post was written in collaboration with <a href=https://claude.ai>Claude</a>.</em><form action=https://buttondown.com/api/emails/embed-subscribe/vinidlidoo class=embeddable-buttondown-form method=post target=_blank><label for=bd-email>Get notified when I post something new.</label><input id=bd-email name=email placeholder=your@email.com type=email><input type=submit value=Subscribe></form></article></main><link href=https://vinidlidoo.github.io/katex.min.css rel=stylesheet><script defer src=https://vinidlidoo.github.io/js/katex.min.js></script><span class=hidden id=copy-success> Copied! </span><span class=hidden id=copy-init> Copy code to clipboard </span><script defer src=https://vinidlidoo.github.io/js/copyCodeToClipboard.min.js></script></div><footer><section><nav class="socials nav-navs"><ul><li><a class="nav-links no-hover-padding social" href=https://vinidlidoo.github.io/atom.xml> <img alt=feed loading=lazy src=https://vinidlidoo.github.io/social_icons/rss.svg title=feed> </a><li><a class="nav-links no-hover-padding social" rel=" me" href=https://github.com/vinidlidoo> <img alt=github loading=lazy src=https://vinidlidoo.github.io/social_icons/github.svg title=github> </a><li><a class="nav-links no-hover-padding social" rel=" me" href=https://x.com/vinidlidoo> <img alt=x loading=lazy src=https://vinidlidoo.github.io/social_icons/x.svg title=x> </a></ul></nav><nav class=nav-navs></nav><div class=credits><small> <p><p>© 2026 Vincent Ethier</p> Powered by <a href=https://www.getzola.org>Zola</a> & <a href=https://github.com/welpo/tabi>tabi</a> </small></div></section><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><h1 class=visually-hidden id=modalTitle>Search</h1><div id=modal-content><div id=searchBar><div aria-hidden=true class=search-icon><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="M784-120 532-372q-30 24-69 38t-83 14q-109 0-184.5-75.5T120-580q0-109 75.5-184.5T380-840q109 0 184.5 75.5T640-580q0 44-14 83t-38 69l252 252-56 56ZM380-400q75 0 127.5-52.5T560-580q0-75-52.5-127.5T380-760q-75 0-127.5 52.5T200-580q0 75 52.5 127.5T380-400Z"/></svg></div><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search… role=combobox spellcheck=false><div class="close-icon interactive-icon" title="Clear search" id=clear-search role=button tabindex=0><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></div></div><div id=results-container><div id=results-info><span id=zero_results> No results</span><span id=one_results> 1 result</span><span id=many_results> $NUMBER results</span><span id=two_results> $NUMBER results</span><span id=few_results> $NUMBER results</span></div><div id=results role=listbox></div></div></div></div></footer>