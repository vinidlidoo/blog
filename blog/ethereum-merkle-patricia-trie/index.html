<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="default-src 'self';font-src 'self' data:;frame-src platform.twitter.com giscus.app;img-src 'self' data: pub-94e31bf482a74272bb61e9559b598705.r2.dev;media-src 'self' pub-94e31bf482a74272bb61e9559b598705.r2.dev;form-action 'self' buttondown.com formspree.io;connect-src 'self';script-src 'self' platform.twitter.com giscus.app" http-equiv=Content-Security-Policy><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://vinidlidoo.github.io name=base><title>
vinidlidoo • Ethereum's Merkle Patricia Trie (Part 1/2)</title><link href=https://vinidlidoo.github.io/img/favicon.png rel=icon type=image/png><link title="vinidlidoo - Atom Feed" href=https://vinidlidoo.github.io/atom.xml rel=alternate type=application/atom+xml><link href="https://vinidlidoo.github.io/custom_subset.css?h=0b9535a28bc3d5bf2321" rel=stylesheet><link href="https://vinidlidoo.github.io/main.css?h=045c365e19a4d50a64bb" rel=stylesheet><link href="https://vinidlidoo.github.io/css/details.css?h=8559b4e109b168c7cfa0" rel=stylesheet><link href="https://vinidlidoo.github.io/css/giscus-fix.css?h=dc895b97fbaf0f0d9908" rel=stylesheet><link href="https://vinidlidoo.github.io/css/newsletter.css?h=c872153c9c367e0bee16" rel=stylesheet><link href="https://vinidlidoo.github.io/css/contact.css?h=572915e83e02eb90c290" rel=stylesheet><link href="https://vinidlidoo.github.io/skins/indigo_ingot.css?h=d429472afbb246441b1a" rel=stylesheet><meta content="light dark" name=color-scheme><meta content="How Ethereum stores its state, commits it to a single hash, and why that design is hitting its limits" name=description><meta content="How Ethereum stores its state, commits it to a single hash, and why that design is hitting its limits" property=og:description><meta content="Ethereum's Merkle Patricia Trie (Part 1/2)" property=og:title><meta content=article property=og:type><meta content="https://vinidlidoo.github.io/img/merkle-patricia-trie-banner.webp?h=7b2b28e3b10def0cf4c6" property=og:image><meta content=1200 property=og:image:width><meta content=670 property=og:image:height><meta content="https://vinidlidoo.github.io/img/merkle-patricia-trie-banner.webp?h=7b2b28e3b10def0cf4c6" name=twitter:image><meta content=summary_large_image name=twitter:card><meta content=en_GB property=og:locale:alternate><link href=https://vinidlidoo.github.io/ja/blog/ethereum-merkle-patricia-trie/ hreflang=ja rel=alternate><meta content=en_GB property=og:locale:alternate><link href=https://vinidlidoo.github.io/blog/ethereum-merkle-patricia-trie/ hreflang=en rel=alternate><meta content=en_GB property=og:locale:alternate><link href=https://vinidlidoo.github.io/fr/blog/ethereum-merkle-patricia-trie/ hreflang=fr rel=alternate><meta content=https://vinidlidoo.github.io/blog/ethereum-merkle-patricia-trie/ property=og:url><meta content=vinidlidoo property=og:site_name><noscript><link href=https://vinidlidoo.github.io/no_js.css rel=stylesheet></noscript><script src=https://vinidlidoo.github.io/js/initializeTheme.min.js></script><script defer src=https://vinidlidoo.github.io/js/themeSwitcher.min.js></script><script src="https://vinidlidoo.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><a href=#main-content id=skip-link>Skip to content</a><header><nav class=navbar><div class=nav-title><a class=home-title href=https://vinidlidoo.github.io/>vinidlidoo</a></div><div class=nav-navs><ul><li><a class="nav-links no-hover-padding" href=https://vinidlidoo.github.io/blog/>blog </a><li><a class="nav-links no-hover-padding" href=https://vinidlidoo.github.io/tags/>tags </a><li><a class="nav-links no-hover-padding" href=https://vinidlidoo.github.io/contact/>contact </a><li class=menu-icons-container><ul class=menu-icons-group><li class="js menu-icon"><div aria-label="Press $SHORTCUT to open search" class="search-icon interactive-icon" title="Press $SHORTCUT to open search" id=search-button role=button tabindex=0><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="M784-120 532-372q-30 24-69 38t-83 14q-109 0-184.5-75.5T120-580q0-109 75.5-184.5T380-840q109 0 184.5 75.5T640-580q0 44-14 83t-38 69l252 252-56 56ZM380-400q75 0 127.5-52.5T560-580q0-75-52.5-127.5T380-760q-75 0-127.5 52.5T200-580q0 75 52.5 127.5T380-400Z"/></svg></div><li class=language-switcher><details class=dropdown><summary aria-label="Language selection" title="Language selection" aria-haspopup=true role=button><div class=language-switcher-icon></div></summary> <div class=dropdown-content role=menu>English<a aria-label=Français href=https://vinidlidoo.github.io/fr/blog/ethereum-merkle-patricia-trie/ lang=fr role=menuitem>Français</a><a aria-label=日本語 href=https://vinidlidoo.github.io/ja/blog/ethereum-merkle-patricia-trie/ lang=ja role=menuitem>日本語</a></div></details><li class="theme-switcher-wrapper js"><div aria-label="Toggle dark mode" title="Toggle dark/light mode" aria-pressed=false class=theme-switcher role=button tabindex=0></div><div aria-label="Reset mode to default" class="theme-resetter arrow" title="Reset mode to default" aria-hidden=true role=button tabindex=0></div></ul></ul></div></nav></header><div class=content id=main-content><main><article class=h-entry><h1 class="p-name article-title">Ethereum's Merkle Patricia Trie (Part 1/2)</h1><a class="u-url u-uid" href=https://vinidlidoo.github.io/blog/ethereum-merkle-patricia-trie/></a><ul class=meta><span class="hidden p-author h-card"> <a class=u-url href=https://vinidlidoo.github.io rel=author title=Vincent>Vincent</a> </span><li><time class=dt-published datetime=2026-02-03>3rd Feb 2026</time><li title="2516 words"><span aria-hidden=true class=separator>•</span>13 min read<li class=tag><span aria-hidden=true class=separator>•</span>Tags: <li class=tag><a class=p-category href=https://vinidlidoo.github.io/tags/crypto/>crypto</a>, <li class=tag><a class=p-category href=https://vinidlidoo.github.io/tags/computer-science/>computer-science</a></ul><ul class="meta last-updated"><li><time class=dt-updated datetime=2026-02-16>Updated on 16th Feb 2026</time><li><span aria-hidden=true class=separator>•</span><a class=external href=https://github.com/vinidlidoo/vinidlidoo.github.io/commits/main/content/blog/ethereum-merkle-patricia-trie.md>See changes</a></ul><p class=p-summary hidden>How Ethereum stores its state, commits it to a single hash, and why that design is hitting its limits<section class="e-content body"><p><img alt="Ethereum's Merkle Patricia Trie" src=/img/merkle-patricia-trie-banner.webp><p>Ethereum is the second-largest blockchain by market cap, securing hundreds of billions of dollars in value. Everyone knows it's a distributed ledger. But how does it actually store all that data? Hundreds of millions of accounts. Smart contracts with their own persistent storage: token balances, NFT ownership records, DeFi positions. Over 250 GB of state, replicated across nearly a million validators worldwide, growing every day. The answer is a data structure called the Merkle Patricia Trie.<p>That may soon change. Ethereum's roadmap calls for replacing it to enable <strong>stateless validation</strong>: verifying blocks without storing the full state. It would be the biggest structural change since genesis. To understand why, we need to understand what's there today, and why it's hitting its limits.<h2 id=the-world-state>The World State</h2><p>Ethereum maintains a <strong>world state</strong>: a key-value store where each key is an address and each value is an account.<p>There are two account types. <strong>Externally owned accounts</strong> (EOAs) are controlled by private keys and can initiate transactions. <strong>Contract accounts</strong> hold code and are triggered by transactions. Both types share the same four data fields:<ul><li><strong>nonce</strong>: a counter that increments with each transaction<li><strong>balance</strong>: native ETH held<sup class=footnote-reference id=fr-1-1><a href=#fn-1>1</a></sup><li><strong>codeHash</strong>: hash of the account's bytecode (empty for EOAs)<li><strong>storageRoot</strong>: hash pointing to the contract's storage (empty for EOAs)</ul><p>Contracts separate storage from code. Storage (token balances, ownership records, configuration) lives in its own key-value store, nested within the world state via <code>storageRoot</code>. Code is stored on-chain but outside the world state, referenced by <code>codeHash</code>. We'll revisit this nested storage when we discuss Merkle proofs.<h2 id=why-a-tree>Why a Tree?</h2><p>If you were building this at your typical tech company, you'd probably use a <em>flat key-value mapping</em>: address as the key, account data as the value. Lookups are fast, updates are straightforward, and the tooling is mature. Why does Ethereum need anything more complex?<p>Ethereum is a distributed system. Nearly a million validators execute the same transactions and must arrive at identical state. To verify consensus, every node produces a <strong>commitment</strong>: a short value that represents the entire state. In Ethereum today, this is a 32-byte hash. This commitment goes in the block header. If yours doesn't match, your state has diverged from the network.<p>This creates two key requirements that a flat key-value mapping can't satisfy.<h3 id=1-efficient-commitment>1. Efficient commitment</h3><p>To compute a commitment from a flat mapping, you'd need to serialize all entries in some deterministic order and hash them together. Now every time you change one balance, you re-serialize and re-hash the entire state. That's O(n) work per block on 250+ GB of data.<p>A tree fixes this. Each node's hash is computed from its children's hashes. Change a leaf, and only the hashes along the path to the root need updating. That's O(log n) operations instead of O(n).<h3 id=2-partial-proofs>2. Partial proofs</h3><p>Alice wants to check her balance without trusting anyone. She can't store 250+ GB of state. With a flat key-value store, the only way to verify a value is to recompute the commitment yourself, which requires having the entire state.<p>A tree fixes this too. To prove a value exists, the prover provides the path from that leaf to the root, plus enough information (a proof) at each level to recompute the hashes. Alice (the verifier) can then reconstruct the root hash from this small proof and check it against the known root.<h2 id=tries-keys-as-paths>Tries: Keys as Paths</h2><p>We've established that we have a key-value store (addresses → accounts) to organize into a tree. How? By using a <strong>trie</strong> (pronounced "try," from re<strong>trie</strong>val).<p><strong>A trie uses the key itself as the path through the tree.</strong> Each character in the key determines which branch to take. For a hex key like <code>4a7f...</code>, you start at the root, branch on <code>4</code>, then <code>a</code>, then <code>7</code>, then <code>f</code>, and so on until you reach the stored value. You don't store keys explicitly; the path <em>is</em> the key.</p><img alt="A hexary trie where hashed addresses become paths: the root branches on hex digits, and following the digits of a hashed address leads to the account data at the leaves. An extension node compresses a chain of single-child branches into one node (the Patricia optimization)." src=/img/trie-structure.webp><p>Ethereum uses a <strong>hexary</strong> trie: one child per hex digit (0-F), giving a maximum <strong>width</strong> of 16. The <strong>depth</strong> depends on key length. Before insertion, each address is hashed with keccak256, producing a 32-byte key (64 hex digits).<sup class=footnote-reference id=fr-2-1><a href=#fn-2>2</a></sup> Contract storage keys are hashed the same way. Both tries have a maximum depth of 64. The <strong>Patricia</strong> variant used by Ethereum compresses the trie by collapsing branch nodes with only one child into an extension node (purple in the figure above).<h2 id=merkle-patricia-tries>Merkle Patricia Tries</h2><p>We have the trie structure. Now we are ready to add the <strong>Merkle</strong> part.<p>In a plain Patricia trie, each node represents a hex digit in the key. In a Merkle trie, <strong>each node also has a hash computed from its children's hashes</strong>. Change any leaf, and every node on the path to the root gets a new hash.<p>How is each node's hash computed? For a branch node, combine references to all of its children and hash the result with keccak256. The output is a single 32-byte hash.</p><img alt="Merkle tree showing hash propagation: each parent's hash is computed from its children's hashes, with color-coded levels showing the recursive pattern" src=/img/merkle-hash-propagation.webp><p>The root hash commits to the entire state, which goes into every block header. Any validator can compute the state root after executing a block's transactions and verify it matches. And because only the path from a changed leaf to the root needs rehashing, we get the O(log n) updates promised earlier—efficient commitment.<p>What property does this rely on? <strong>Collision resistance</strong>: it's computationally infeasible to find two distinct states that produce the same keccak256 root. The root hash uniquely identifies the state.<p>The actual Ethereum implementation is more complex: RLP encoding to serialize nodes before hashing, different array specs for different node types (branch, leaf, and extension), flags for even/odd path lengths.<details><summary>More on the implementation</summary> <p>Trie nodes are stored in a key-value database (historically LevelDB, though clients now vary). Each key is the keccak256 hash of the node's RLP-encoded content; each value is the node itself. The three node types:</p> <ul><li><strong>Branch</strong>: a 17-item array <code>[v0, v1, ..., v15, vt]</code>. Each <code>vi</code> points to a child for hex digit <code>i</code> (or empty). <code>vt</code> holds a value if a key terminates here.<li><strong>Leaf</strong>: a 2-item array <code>[encodedPath, value]</code>. The path encodes remaining key nibbles; the value is the account data.<li><strong>Extension</strong>: a 2-item array <code>[encodedPath, nextNode]</code>. Compresses chains of single-child branches into one node (the Patricia optimization).</ul> <p>To look up a key, start from the root hash (in the block header), fetch the root node, follow the appropriate child based on the next hex digit, and repeat. Each level is a random disk read. The <a href=https://ethereum.org/developers/docs/data-structures-and-encoding/patricia-merkle-trie/>Ethereum documentation</a> covers this in detail.</p></details><h2 id=merkle-proofs>Merkle Proofs</h2><p>We claimed earlier that a tree enables partial proofs: verifying a single value without the full state. Here's how.<p>Alice wants to verify her Ethereum balance from her phone's wallet. The full state is 250+ GB; she can't store it. Her wallet might query a third-party node provider like <a href=https://www.infura.io/>Infura</a> or <a href=https://www.alchemy.com/>Alchemy</a> behind the scenes, but that provider could be compromised, or lying, or hacked. She'd have no way to know.<p>The Merkle structure offers an alternative. Alice (<strong>the verifier</strong>) stores just block headers (a few KB each). She asks <em>any</em> full node (<strong>the prover</strong>) for her balance <em>plus a proof</em>. She recomputes the root from the proof. If it matches the state root in the header, the balance is correct, mathematically guaranteed.<h3 id=proof-and-verification>Proof and Verification</h3><p>Consider a trie of depth $d$ and a path $k = (k_0, k_1, \ldots, k_{d-1})$ where each $k_i$ is a hex digit in the account's hashed key. To prove the value at this path, the prover provides:<ul><li>The leaf value $v$ (all four account fields)<li>At each depth $i$, up to 15 sibling hashes $S_i = \lbrace h_{i,j} : j \neq k_i \rbrace$</ul><p>Verification reconstructs the root bottom-up. Hash the leaf, then work up the tree, combining with siblings at each level:<p>$$H_d = \text{hash}(v)$$<p>$$H_{i-1} = \text{hash}(h_{i,0} | h_{i,1} | \cdots | h_{i,15})$$<p>$$\text{where } h_{i,j} = \left\lbrace \begin{array}{ll} H_i & \text{if } j = k_{i-1} \\ S_i[j] & \text{otherwise} \end{array} \right.$$<p>If $H_0$ matches the state root, the proof is valid. The prover must supply the full account (if any field were wrong, the leaf hash would differ and the proof would fail), but the verifier never sees the rest of the state; just the sibling hashes along the path:</p><img alt="Merkle proof verification: Alice's account is hashed bottom-up through three levels of the hexary trie. At each level, the computed hash (orange) is combined with 15 sibling hashes (green, provided by the prover) to produce the next hash. Gray subtree hints show the rest of the tree that the verifier never needs to see." src=/img/merkle-proof.webp><details><summary>Walkthrough</summary> <p>Suppose hashing Alice's address produces a key starting with <code>7a4...</code>. In a simplified 3-level trie, the path is $k = (7, a, 4)$. The proof contains Alice's account data plus up to 45 sibling hashes (15 at each of the 3 levels). Verification proceeds bottom-up:</p> <ol><li>Hash the account data → $H_3$<li>Slot $H_3$ into position <code>4</code> among its siblings, hash all 16 → $H_2$<li>Slot $H_2$ into position <code>a</code> among its siblings, hash all 16 → $H_1$<li>Slot $H_1$ into position <code>7</code> among its siblings, hash all 16 → $H_0$<li>Check: does $H_0$ match the state root in the block header?</ol></details><p>What about values in contract storage? Recall that each account has a <code>storageRoot</code>, the root of another trie containing that contract's storage. To prove a storage value, you provide two proofs: one from the state root to the account (which includes <code>storageRoot</code>), and another from <code>storageRoot</code> to the storage slot. The same verification logic applies, just nested.<h2 id=smaller-proofs-bigger-possibilities>Smaller Proofs, Bigger Possibilities</h2><p>Alice can verify a single state value with a Merkle proof. Validators do something similar thousands of times per block: read state, execute transactions, compute a new state root.<p>Ethereum's core commitment is decentralization. As Vitalik Buterin <a href=https://decrypt.co/154990/future-ethereum-upgrades-could-allow-full-nodes-to-run-on-mobile-phones-vitalik-buterin>put it</a>: "In the longer term there's a plan to maintain fully verified Ethereum nodes where you could literally run it on your phone." Validation should be accessible to ordinary hardware, not just data centers.<p>Currently the world state <a href=https://www.theblock.co/post/383156/ethereum-foundation-researchers-warn-of-storage-burden-from-state-bloat>grows by roughly a gigabyte per week</a>. As it grows, less of the trie fits in memory, so more lookups require random disk reads. As I covered in <a href=https://vinidlidoo.github.io/blog/understanding-parquet-files/>a previous article</a>, accessing data on disk can create bottlenecks. To meet Ethereum's 12-second slot constraint, validators need faster storage (SSDs at minimum, increasingly NVMe-class), pushing costs upward and working against the decentralization goal.<p>But what if validators didn't store state at all? Instead of reading from disk, they could receive proofs for every value a block touches. The same trick Alice used, scaled up.<p>The problem is proof size. Each proof requires sibling hashes at every level: 15 siblings × 64 levels × 32 bytes ≈ 30 KB worst case, <a href=https://notes.ethereum.org/@vbuterin/verkle_tree_eip>~3 KB on average</a>. With current blocks using <a href=https://etherscan.io/chart/gasused>~30M gas</a> and cold state reads costing <a href=https://eips.ethereum.org/EIPS/eip-2929>2100 gas each</a>,<sup class=footnote-reference id=fr-3-1><a href=#fn-3>3</a></sup> a block easily touches thousands of values. At ~3 KB average, that's several MB of additional bandwidth per block. 10 MB incremental per block would be over 2 TB/month in extra bandwidth per validator: the kind of overhead that pushes solo stakers toward data centers.<p>So proof size is a binding constraint. Shrink the proofs, and stateless validation becomes viable.<h2 id=what-s-next>What's Next</h2><p>One approach to shrinking proofs: replace hash-based commitments with <strong>polynomial commitments</strong>. Verkle trees do exactly this, reducing proofs from several KB to less than 150 bytes each. Ethereum's state tree is actually now headed a different way (a <a href=https://eips.ethereum.org/EIPS/eip-7864>binary trie</a> with post-quantum hash-based commitments), but the underlying cryptography is very relevant: polynomial commitments are the foundation of <strong>zero-knowledge proofs</strong>, a rapidly advancing field with applications across Ethereum's scaling roadmap and well beyond. <a href=https://vinidlidoo.github.io/blog/verkle-trees-polynomial-commitments/>Part 2</a> covers how Verkle trees work, building on <a href=https://vinidlidoo.github.io/blog/math-behind-private-key/>finite fields and elliptic curves</a>.<p>State growth adds another problem: stateless validation may let validators skip storing state, but the full state must still exist somewhere to construct blocks. <a href=https://ethresear.ch/t/hyper-scaling-state-by-creating-new-forms-of-state/24052>New storage primitives</a> like expiring storage and UTXO-style records are currently being discussed and could keep that 250+ GB from growing indefinitely.<hr><h2 id=appendix>Appendix</h2><details><summary>Could we shrink Merkle proofs by reshaping the tree?</summary> <p>You could by reducing tree width, but in the current architecture the tradeoffs are steep. Each level of trie traversal is a random disk read: the root node points to a child at one location, which points to another child elsewhere. A hexary trie with effective depth ~8-10 means 8-10 random reads per lookup. A binary trie would have depth ~30-40. Even on NVMe, random reads cost tens of microseconds each. Multiply by thousands of state accesses per block, and going binary would blow through the 12-second slot time. Hexary branching was a natural fit for hex-encoded keys, while keeping the trie shallow enough for fast lookups.</p> <p>And the payoff isn't even that good. A binary trie needs only 1 sibling hash per level instead of 15, but it's 4× deeper (since $\log_2 n = 4 \log_{16} n$). Net effect: 15× fewer siblings per level, 4× more levels, so proofs shrink by roughly 15/4 ≈ 4×. If hexary proofs run ~10 MB per block, binary gets you to ~2.5 MB... still a significant network overhead.</p> <p>Under stateless validation, where validators verify proofs rather than traverse the trie, depth stops being a bottleneck, but the proof-size overhead remains.</p></details><hr><section class=footnotes><ol class=footnotes-list><li id=fn-1><p>Other tokens like USDC are tracked in contract storage. <a href=#fr-1-1>↩</a></p><li id=fn-2><p>keccak256 is Ethereum's hash function; the pre-standardization version of what became SHA-3. Hashing prevents attackers from crafting addresses that create pathologically unbalanced branches. <a href=#fr-2-1>↩</a></p><li id=fn-3><p>EIP-2929 distinguishes cold reads (first access, 2100 gas) from warm reads (subsequent, 100 gas). Using cold cost here underestimates total accesses. <a href=#fr-3-1>↩</a></p></ol></section></section><p class=credit><em>This post was written in collaboration with <a href=https://claude.ai>Claude</a>.</em><form action=https://buttondown.com/api/emails/embed-subscribe/vinidlidoo class=embeddable-buttondown-form method=post target=_blank><label for=bd-email>Get notified when I post something new.</label><input id=bd-email name=email placeholder=your@email.com type=email><input type=submit value=Subscribe></form></article></main><link href=https://vinidlidoo.github.io/katex.min.css rel=stylesheet><script defer src=https://vinidlidoo.github.io/js/katex.min.js></script><span class=hidden id=copy-success> Copied! </span><span class=hidden id=copy-init> Copy code to clipboard </span><script defer src=https://vinidlidoo.github.io/js/copyCodeToClipboard.min.js></script></div><footer><section><nav class="socials nav-navs"><ul><li><a class="nav-links no-hover-padding social" href=https://vinidlidoo.github.io/atom.xml> <img alt=feed loading=lazy src=https://vinidlidoo.github.io/social_icons/rss.svg title=feed> </a><li><a class="nav-links no-hover-padding social" rel=" me" href=https://github.com/vinidlidoo> <img alt=github loading=lazy src=https://vinidlidoo.github.io/social_icons/github.svg title=github> </a><li><a class="nav-links no-hover-padding social" rel=" me" href=https://x.com/vinidlidoo> <img alt=x loading=lazy src=https://vinidlidoo.github.io/social_icons/x.svg title=x> </a></ul></nav><nav class=nav-navs></nav><div class=credits><small> <p><p>© 2026 Vincent Ethier</p> Powered by <a href=https://www.getzola.org>Zola</a> & <a href=https://github.com/welpo/tabi>tabi</a> </small></div></section><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><h1 class=visually-hidden id=modalTitle>Search</h1><div id=modal-content><div id=searchBar><div aria-hidden=true class=search-icon><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="M784-120 532-372q-30 24-69 38t-83 14q-109 0-184.5-75.5T120-580q0-109 75.5-184.5T380-840q109 0 184.5 75.5T640-580q0 44-14 83t-38 69l252 252-56 56ZM380-400q75 0 127.5-52.5T560-580q0-75-52.5-127.5T380-760q-75 0-127.5 52.5T200-580q0 75 52.5 127.5T380-400Z"/></svg></div><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search… role=combobox spellcheck=false><div class="close-icon interactive-icon" title="Clear search" id=clear-search role=button tabindex=0><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></div></div><div id=results-container><div id=results-info><span id=zero_results> No results</span><span id=one_results> 1 result</span><span id=many_results> $NUMBER results</span><span id=two_results> $NUMBER results</span><span id=few_results> $NUMBER results</span></div><div id=results role=listbox></div></div></div></div></footer>